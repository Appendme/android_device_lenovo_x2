/*
 * tfa98xx.c
 *
 * this is the interface to the Tfa98xx API
 *
 *  Created on: Apr 5, 2012
 *      Author: wim
 */

#define LOG_TAG "tfa89xx"
#define LOG_NDEBUG 0

#include <stdio.h>
#include <assert.h>
#ifndef WIN32
#include <unistd.h>
#else
#include <Windows.h>
#endif
#include <stdlib.h>
#include <math.h>
#include <string.h>


#include "../inc/nxpTfa98xx.h"
#include "../inc/tfa98xxCalibration.h"
#include "../../Tfa98xx/inc/Tfa98xx_Registers.h"

/*
 * static profile definitions
 */
static int predefI2sRoute[]={TFA_PROFILE0_I2SINPUT, TFA_PROFILE1_I2SINPUT, TFA_PROFILE0_I2SINPUT};
static int predefSampleRate[]={TFA_PROFILE0_SAMPLERATE, TFA_PROFILE1_SAMPLERATE,TFA_PROFILE2_SAMPLERATE};

#define false 0
#define true  1

#ifdef WIN32
int usleep(long usec)
{
	Sleep(usec/1000);
	return 0;
}
#endif
/*
 * module globals
 */
static void coldStartup(Tfa98xx_handle_t handle);
static   char *paramsName[]={  "patch",
        "speaker",
        "preset",
        "config",
        "equalizer"};
static int tfaHardwarePoweredDown = false; // default is self detect
nxpTfa98xxParameters_t tfaParams = {0};  // TODO do we allow tfaParams to be global (needed for speaker file update?
int nxpTfaCurrentProfile=0; // TODO deal with profiles
static int nxpTfaCurrentVolstep=0;

int tfa98xx_trace = 0;
int tfa98xx_verbose = 0;
int tfa98xx_quiet = 0;

#define TRACEIN  if(tfa98xx_trace) printf("Enter %s\n", __FUNCTION__);
#define TRACEOUT if(tfa98xx_trace) printf("Leave %s\n", __FUNCTION__);

#define MAXDEV ( (int) (sizeof(handles)/sizeof(Tfa98xx_handle_t)) )
static int idx = 0;         // TODO cleanup for single device

unsigned char  tfa98xxI2cSlave=TFA_I2CSLAVEBASE; // global for i2c access
#define I2C ((tfa98xxI2cSlave+idx)*2)  // TODO assure correct address
#define I2C_CHUNKSIZE (256) // max i2c xfer length
#define HAVE_ATOF 0 //1


#define BIQUAD_COEFF_SIZE       6
#define Tfa98xx_BIQUAD_LENGTH (1+(BIQUAD_COEFF_SIZE*3)) // TODO put this in API def?
static char latest_errorstr[64];

/*
 * clock control
 */
/*
 * I2S clock is present
 *
  *  * if power was off
 *  *   initialize
 *  *   configure
 *
 *  * check if we really have a stable clock
 *  * cancel amp_mute
 *  * clear powerdown state
 *
 *  return:
 *      nxpTfa98xx_Error_Ok
 *      nxpTfa98xx_Error_NoClock
 *      nxpTfa98xx_Error_LowAPI
 *
 */
nxpTfa98xx_Error_t nxpTfa98xxClockEnable(Tfa98xx_handle_t *handlesIn )
{
    unsigned short statusReg = 0;
    Tfa98xx_Error_t err87;
    nxpTfa98xx_Error_t err;
    int loop=100;

    TRACEIN

    statusReg = tfa98xxReadRegister(0, handlesIn );
    /*
     *  cold start
     */
    // bit11 is flag_cold_started
#define COLD ((1 << 11) & statusReg)
   if (tfaHardwarePoweredDown | COLD)
   {
      err = tfa98xxInit(handlesIn[idx]);// now check if too fast

      do
      {
         usleep(10000);
        	/* check if we really have a stable clock */
        	statusReg = tfa98xxReadRegister(0, handlesIn);
        	if ((1 << 6) & statusReg)
         {
        		//printf("%x\n", statusReg);
        		break;
         }
      }
      while(loop--);
      if (loop==0)
      {
         return nxpTfa98xx_Error_NoClock;
      }

      err = tfa98xxLoadParams(handlesIn[idx]);

      err87 = Tfa98xx_SetConfigured(handlesIn[idx]);
      PrintAssert(err87);
      err87 = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Off);
      PrintAssert(err87);

      if (nxpTfa98xx_Error_Ok == err)
         tfaHardwarePoweredDown = false; // only once if told so
   }
   /*
   * warm start
   */
   else
   {
      /* check if we have a stable clock */
//    if (0 == ((1 << 6) & statusReg) )
//       tfa98xxInit(); // if not init again
      err87 = Tfa98xx_Powerdown(handlesIn[idx], false);
      if (err87 != Tfa98xx_Error_Ok)
      {
         return (nxpTfa98xx_Error_t) err87;
      }
   }

   /* check if we have a stable clock */
   if (0 == ((1 << 6) & tfa98xxReadRegister(0, handlesIn)) )
   {
      return nxpTfa98xx_Error_NoClock;
   }

   err87 = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Off);
   if (err87 != Tfa98xx_Error_Ok)
   {
      return (nxpTfa98xx_Error_t) err87;
   }

   TRACEOUT

   return err87 == Tfa98xx_Error_Ok ?
         nxpTfa98xx_Error_Ok : nxpTfa98xx_Error_LowAPI;

}

/*
 * I2S clock will stop
 *
 * * set amp_mute (implicit soft mute)
 * * set powerdown
 *
  *  return:
 *      nxpTfa98xx_Error_Ok
 *      nxpTfa98xx_Error_LowAPI
 *
 */
nxpTfa98xx_Error_t nxpTfa98xxClockDisable(Tfa98xx_handle_t *handlesIn   )
{
    Tfa98xx_Error_t err87;
    nxpTfa98xx_Error_t err;
    unsigned short statusReg;

    TRACEIN

    statusReg = tfa98xxReadRegister(0, handlesIn);     // get status, also open device if not done yet


#define SWS ((1 << 12) & statusReg)
    // check if amp is already off
    if ( SWS == 0 ) {
        TRACEOUT
        return nxpTfa98xx_Error_Ok;
    }
    err87 = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Amplifier);
    if (err87 != Tfa98xx_Error_Ok)
    {
      return (nxpTfa98xx_Error_t) err87;
    }

    err87 = Tfa98xx_Powerdown(handlesIn[idx], true);
    if (err87 != Tfa98xx_Error_Ok)
    {
      return (nxpTfa98xx_Error_t) err87;
    }

    // amp still on ?
    err = ( SWS & tfa98xxReadRegister(0, handlesIn)) ? nxpTfa98xx_Error_AmpOn : nxpTfa98xx_Error_Ok;

    TRACEOUT

    return err87 == Tfa98xx_Error_Ok ?
            err : nxpTfa98xx_Error_LowAPI;  //  lower level is worse
}
static int tfa98xxSelectStereo(Tfa98xx_handle_t *handlesIn )
{
   Tfa98xx_Error_t err87;
   err87 = Tfa98xx_SelectChannel(handlesIn[0], Tfa98xx_Channel_L);
	err87 = Tfa98xx_SelectChannel(handlesIn[1], Tfa98xx_Channel_R);

	/* ensure stereo routing is correct: in this example we use
	 * gain is on L channel from 1->2
	 * gain is on R channel from 2->1
	 * on the other channel of DATAO we put Isense
	 */

	err87 = Tfa98xx_SelectI2SOutputLeft(handlesIn[0], Tfa98xx_I2SOutputSel_DSP_Gain);
	err87 = Tfa98xx_SelectStereoGainChannel(handlesIn[1], Tfa98xx_StereoGainSel_Left);

	err87 = Tfa98xx_SelectI2SOutputRight(handlesIn[1], Tfa98xx_I2SOutputSel_DSP_Gain);
	err87 = Tfa98xx_SelectStereoGainChannel(handlesIn[0], Tfa98xx_StereoGainSel_Right);

	err87 = Tfa98xx_SelectI2SOutputRight(handlesIn[0], Tfa98xx_I2SOutputSel_CurrentSense);
	err87 = Tfa98xx_SelectI2SOutputLeft(handlesIn[1], Tfa98xx_I2SOutputSel_CurrentSense);

   return err87;
}

nxpTfa98xx_Error_t nxpTfa98xxClockEnableStereo(Tfa98xx_handle_t *handlesIn )
{
   unsigned short statusReg = 0;
   Tfa98xx_Error_t err87;
   nxpTfa98xx_Error_t err;
   int i = 0;
   int loop=100;

   for (i = 0; i < 2; i++)
   {
      TRACEIN

      if( handlesIn[i] == -1)
      {
        err87 = Tfa98xx_Open(((tfa98xxI2cSlave+i)*2), &handlesIn[i] );
        if (err87) return (nxpTfa98xx_Error_t) err87;
      }
      err87 = Tfa98xx_ReadRegister16( handlesIn[i] , 0, &statusReg);
      /*
      *  cold start
      */
      // bit11 is flag_cold_started
#define COLD ((1 << 11) & statusReg)
      if (tfaHardwarePoweredDown | COLD)
      {
         err = tfa98xxInit(handlesIn[i]);// TODO check if too fast
         do
         {
            usleep(10000);
        	   /* check if we really have a stable clock */
        	   statusReg = tfa98xxReadRegister(0, handlesIn);
        	   if ((1 << 6) & statusReg)
            {
        		   //printf("%x\n", statusReg);
        		   break;
            }
         }
         while(loop--);
         if (loop==0)
         {
            return nxpTfa98xx_Error_NoClock;
         }

         err = tfa98xxLoadParams(handlesIn[i]);

         if (i == 0)
         {
            tfa98xxSelectStereo(handlesIn);
         }

         err87 = Tfa98xx_SetConfigured(handlesIn[i]);
         err87 = Tfa98xx_SetMute(handlesIn[i], Tfa98xx_Mute_Off);

         if (nxpTfa98xx_Error_Ok == err)
         {
            tfaHardwarePoweredDown = false; // only once if told so
         }
      }
      /*
      * warm start
      */
      else
      {
         /* check if we have a stable clock */
         /*if (0 == ((1 << 6) & statusReg) )
         tfa98xxInit(); // if not init again */
         err87 = Tfa98xx_Powerdown(handlesIn[i], false);
         if (err87 != Tfa98xx_Error_Ok)
         {
            return (nxpTfa98xx_Error_t) err87;
         }
      }

      /* check if we have a stable clock */
      err87 = Tfa98xx_ReadRegister16( handlesIn[i] , 0, &statusReg);

      if (0 == ((1 << 6) & statusReg) )
      {
         return nxpTfa98xx_Error_NoClock;
      }

      err87 = Tfa98xx_SetMute(handlesIn[i], Tfa98xx_Mute_Off);
      if (err87 != Tfa98xx_Error_Ok)
      {
         return (nxpTfa98xx_Error_t) err87;
      }


      TRACEOUT
   }
   return err87 == Tfa98xx_Error_Ok ?
            nxpTfa98xx_Error_Ok : nxpTfa98xx_Error_LowAPI;

}

/*
 * I2S clock will stop
 *
 * * set amp_mute (implicit soft mute)
 * * set powerdown
 *
  *  return:
 *      nxpTfa98xx_Error_Ok
 *      nxpTfa98xx_Error_LowAPI
 *
 */
nxpTfa98xx_Error_t nxpTfa98xxClockDisableStereo(Tfa98xx_handle_t *handlesIn)
{
   Tfa98xx_Error_t err87;
   nxpTfa98xx_Error_t err;
   unsigned short statusReg;
   int i = 0;

   for (i = 0; i < 2; i++)
   {
      TRACEIN
      if( handlesIn[i] == -1)
      {
        err87 = Tfa98xx_Open(((tfa98xxI2cSlave+i)*2), &handlesIn[i] );
        if (err87) return (nxpTfa98xx_Error_t) err87;
      }

      /*get status, also open device if not done yet*/
      err87 = Tfa98xx_ReadRegister16( handlesIn[i] , 0, &statusReg);

#define SWS ((1 << 12) & statusReg)
      // check if amp is already off
      if ( SWS == 0 )
      {
         TRACEOUT
         return nxpTfa98xx_Error_Ok;
      }
      err87 = Tfa98xx_SetMute(handlesIn[i], Tfa98xx_Mute_Amplifier);
      if (err87 != Tfa98xx_Error_Ok)
      {
         return (nxpTfa98xx_Error_t) err87;
      }

      err87 = Tfa98xx_Powerdown(handlesIn[i], true);
      if (err87 != Tfa98xx_Error_Ok)
      {
         return (nxpTfa98xx_Error_t) err87;
      }

      /*amp still on ?*/
      err87 = Tfa98xx_ReadRegister16( handlesIn[i] , 0, &statusReg);
      err = ( SWS & statusReg) ? nxpTfa98xx_Error_AmpOn : nxpTfa98xx_Error_Ok;

      TRACEOUT
   }
   return err87 == Tfa98xx_Error_Ok ?
            err : nxpTfa98xx_Error_LowAPI;  //  lower level is worse
}
/*
 * do a cold start init on next clock enable
 *
 *
 */
nxpTfa98xx_Error_t nxpTfa98xxPowerdown(void) // TODO is nxpTfa98xxClockEnable with init param enough? of POR bit sufficient
{

    TRACEIN

    tfaHardwarePoweredDown = true;      // just set the flag

    TRACEOUT

    return nxpTfa98xx_Error_Ok;
}
const char* nxpTfa98xxGetErrorString(nxpTfa98xx_Error_t error) {
    const char* pErrStr;

    switch (error) {
    case nxpTfa98xx_Error_Ok:
        pErrStr = "Ok";
        break;
    case nxpTfa98xx_Error_Fail:
        pErrStr = "generic failure";
        break;
    case nxpTfa98xx_Error_NoClock:
        pErrStr = "No I2S Clock";
        break;
    case nxpTfa98xx_Error_LowAPI:
        pErrStr = "error returned from lower API level";
        break;
    case nxpTfa98xx_Error_BadParam:
        pErrStr = "wrong parameter";
        break;
    case nxpTfa98xx_Error_AmpOn:
        pErrStr = "amp is still running";
        break;
    case nxpTfa98xx_Error_DSP_not_running:
        pErrStr = "DSP is not running";
        break;

    default:
        sprintf(latest_errorstr, "Unspecified error (%d)", (int) error);
        pErrStr = latest_errorstr;
    }
    return pErrStr;
}


/*
 * basic customer/application specific settings
 *  called during init
 *  TODO is this correct & complete :customer/application specific settings
 */
static Tfa98xx_Error_t tfaInitSettings(Tfa98xx_handle_t handle)
{
   Tfa98xx_Error_t err;
   unsigned short status;
   int tries = 0;

   TRACEIN

   if (tfa98xx_quiet == 0)
        printf("writing initialisation settings to device\n");

   err = Tfa98xx_Init(handle);
   PrintAssert(err);
   if (err) // likely to occur here if any error
        return err;

   err = Tfa98xx_SetSampleRate(handle, TFA_PROFILE0_SAMPLERATE); //TODO get this from profile
   PrintAssert(err);
   err = Tfa98xx_SelectChannel(handle, idx==0 ? Tfa98xx_Channel_L : Tfa98xx_Channel_R); // TODO fix for stereo
   PrintAssert(err);
   err = Tfa98xx_SelectAmplifierInput(handle, Tfa98xx_AmpInputSel_I2SLeft);
   PrintAssert(err);

   /* start at -12 dB */
   err = Tfa98xx_SetVolume(handle, -1.0);
   PrintAssert(err);

   /* some other registers must be set for optimal amplifier behaviour */
   if (Tfa98xx_Error_Ok == err)
   {
      err = Tfa98xx_WriteRegister16(handle, 0x70, 0x01);
   }

   err = Tfa98xx_Powerdown(handle, 0);
   PrintAssert(err);

   printf("Waiting for AMPS to start up\n"); // TODO make a clock wait in runtime
	err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUS, &status);

   while ( ( (status & TFA98XX_STATUS_AMPS) == 0) &&
            (tries < TFA98XX_API_WAITRESULT_NTRIES) )
	{
		/* not ok yet */
		err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUS, &status);
		assert(err == Tfa98xx_Error_Ok);
      tries++;
	}
	usleep(10000);

   if (tries >= TFA98XX_API_WAITRESULT_NTRIES)
   {
      printf("AMPS start up timed-out\n");
   }

   /* some other registers must be set for optimal amplifier behaviour */
   if (Tfa98xx_Error_Ok == err)
   {
      err = Tfa98xx_WriteRegister16(handle, 0x09, 0x024C);
   }

    TRACEOUT

    return err;
}
/*
 * minimal settings for sound
 */
void tfaQuickInit(Tfa98xx_handle_t *handlesIn   )
{
   Tfa98xx_Error_t err = Tfa98xx_Error_Other;

   TRACEIN

   if( handlesIn[idx] == -1 )
   {
      err = Tfa98xx_Open(I2C, &handlesIn[idx] );
      PrintAssert( err) ;
   }

   if ( Tfa98xx_Error_Ok != err)
   {
      err = Tfa98xx_Init(handlesIn[idx]);
   }

   // basic settings for quickset
   Tfa98xx_WriteRegister16( handlesIn[idx], 4,0x880B ); //48 kHz I2S with coolflux in Bypass
   Tfa98xx_WriteRegister16( handlesIn[idx], 9,0x0219 ); //1.0 uF coil and other system settings
   Tfa98xx_WriteRegister16( handlesIn[idx], 9,0x0618 ); //power on

   TRACEOUT

}

/*
 * initialize the API
 */
int tfa98xxInit( Tfa98xx_handle_t handle )
{
    Tfa98xx_Error_t err = Tfa98xx_Error_Other;

    TRACEIN

    if( handle == -1 )
    {
       err = Tfa98xx_Open(I2C, &handle );
       PrintAssert( err );
       if (err) return err;

    }
    err = tfaInitSettings(handle); // already PrintAsserted

    TRACEOUT

    return err;
}
/*
 *  int registers and coldboot dsp
 */
int tfa98xxReset( Tfa98xx_handle_t *handlesIn )
{
    Tfa98xx_Error_t err = Tfa98xx_Error_Ok;

    TRACEIN

   if( handlesIn[idx] == -1 )
   {
      err = Tfa98xx_Open(I2C, &handlesIn[idx] );
      PrintAssert( err) ;

   }

    if( handlesIn[idx] != -1 )
    {
       coldStartup(handlesIn[idx]);
    }

    TRACEOUT

    return err;
}

/*
 * close all devices
 */
int tfa98xxClose( Tfa98xx_handle_t *handlesIn )
{
   Tfa98xx_Error_t err = Tfa98xx_Error_Other;

   TRACEIN

   if( handlesIn[idx] == -1 )
   {
      err = Tfa98xx_Close(handlesIn[idx] );
      PrintAssert( err );
      if (err) return err;
   }

   TRACEOUT

   return err;
}

/*
 * parse the equalizer ascii input line into int
 */
static int tfa98xxGetInt(const char* s, int* r)
{
    int i;

    i = 0;
    while (s[i] == ' ')
    {
        i++;
    }
    *r = atoi(s + i);
    while ((s[i] != 0) && (s[i] != ' '))
    {
        i++;
    }
    return i;
}
/*
 * parse the equalizer ascii input line into float
 */
static int tfa98xxGetFloat(const char* s, float* f)
{
    int i;
    int  minus;
    float res;
    float d;
    char *end;

    res = 0;
    minus = false;
    i = 0;
    while (s[i] == ' ')
    {
        i++;
    }
#if HAVE_ATOF
    *f = strtof(s + i, &end);
    while ((s[i] != 0) && (s[i] != ' '))
    {
        i++;
    }
#else
    if (s[i] == '-')
    {
        minus = true;
        i++;
    }
    else if (s[i] == '+')
    {
        i++;
    }
    while ((s[i] >= '0') * (s[i] <= '9'))
    {
        res = res * 10 + s[i] - '0';
        i++;
    }
    if (s[i] == '.')
    {
        i++;
        d = 10;
        while ((s[i] >= '0') * (s[i] <= '9'))
        {
            res = res + ((float)(s[i] - '0')) / d;
            i++;
            d *= 10;
        }
    }
    if (minus)
    {
        res = -res;
    }
    *f = res;
#endif
    return i;
}

static Tfa98xx_Error_t tfa98xxSetEqualizer(Tfa98xx_handle_t handle, const char* eqData) {
    int i;
    int ind;
    float b0, b1, b2, a1, a2;
    Tfa98xx_Error_t err = Tfa98xx_Error_Ok;

    if( handle == -1) {
        err = Tfa98xx_Open(I2C, &handle );
        PrintAssert( err);
        if (err) return err;
    }

    i = 0;
    ind = 0;
    while (eqData[i] != 0) {
        /* read biquad index + 5 parameters */
        i += tfa98xxGetInt(eqData + i, &ind);
        i += tfa98xxGetFloat(eqData + i, &b0);
        i += tfa98xxGetFloat(eqData + i, &b1);
        i += tfa98xxGetFloat(eqData + i, &b2);
        i += tfa98xxGetFloat(eqData + i, &a1);
        i += tfa98xxGetFloat(eqData + i, &a2);
        /* skip to the next line */
        while ((eqData[i] != 0) && (eqData[i] <= ' ')) {
            i++;
        }

        if ((b0 != 1) || (b1 != 0) || (b2 != 0) || (a1 != 0) || (a2 != 0)) {
            err = Tfa98xx_DspBiquad_SetCoeff(handle, ind, b0, b1, b2, a1, a2);
            PrintAssert( err);
            if (err) return err;
        } else {
            err = Tfa98xx_DspBiquad_Disable(handle, ind);
            PrintAssert( err);
            if (err) return err;
        }

    }
    for (i = ind + 1; i <= 10; i++) {
        err = Tfa98xx_DspBiquad_Disable(handle, ind);
        PrintAssert( err);
        if (err) return err;
    }

    return err;
}

static Tfa98xx_Error_t tfa98xxSetEqualizerStereo(Tfa98xx_handle_t *handlesIn, const char* eqData)
{
    int i;
    int ind;
    float b0, b1, b2, a1, a2;
    Tfa98xx_Error_t err = Tfa98xx_Error_Ok;

    if( handlesIn[idx] == -1) {
        err = Tfa98xx_Open(I2C, &handlesIn[idx] );
        PrintAssert( err);
        if (err) return err;
    }

    i = 0;
    ind = 0;
    while (eqData[i] != 0) {
        /* read biquad index + 5 parameters */
        i += tfa98xxGetInt(eqData + i, &ind);
        i += tfa98xxGetFloat(eqData + i, &b0);
        i += tfa98xxGetFloat(eqData + i, &b1);
        i += tfa98xxGetFloat(eqData + i, &b2);
        i += tfa98xxGetFloat(eqData + i, &a1);
        i += tfa98xxGetFloat(eqData + i, &a2);
        /* skip to the next line */
        while ((eqData[i] != 0) && (eqData[i] <= ' ')) {
            i++;
        }

        if ((b0 != 1) || (b1 != 0) || (b2 != 0) || (a1 != 0) || (a2 != 0)) {
            err = Tfa98xx_DspBiquad_SetCoeffMultiple(2, handlesIn, ind, b0, b1, b2, a1, a2);
            PrintAssert( err);
            if (err) return err;
        } else {
            err = Tfa98xx_DspBiquad_DisableMultiple(2, handlesIn, ind);
            PrintAssert( err);
            if (err) return err;
        }

    }
    for (i = ind + 1; i <= 10; i++) {
        err = Tfa98xx_DspBiquad_DisableMultiple(2, handlesIn, ind);
        PrintAssert( err);
        if (err) return err;
    }

    return err;
}


/*
 * load a volume step
 */
nxpTfa98xx_Error_t nxpTfa98xxSetVolume( Tfa98xx_handle_t *handlesIn, int profile, int step ) // apply volume step, or mute
{
    nxpTfa98xx_Error_t err = nxpTfa98xx_Error_Ok;
    Tfa98xx_Error_t err87;
    unsigned short statusReg, sysctrlReg;

    TRACEIN

    statusReg = tfa98xxReadRegister(0, handlesIn); // TODO what to check , will fail furtheron
    // check if this is mute
    if (TFA_ISMUTE(step)) {
        err87 = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Digital); // soft mute
        if (err87 != Tfa98xx_Error_Ok)
         {
            return err87;
         }
        if (tfa98xx_verbose)
            printf("SetMute\n");
    } else {
        if (tfa98xx_verbose)
            printf("Setting volume to %3.1f dB\n",tfaParams.profile[profile].vstep[step].attenuation );
        // load step
        if (step > tfaParams.profile[nxpTfaCurrentProfile].vsteps){
            return nxpTfa98xx_Error_BadParam;
        }
        //
        // only reload  if changed profile
        //
        if (nxpTfaCurrentProfile != profile) {
            err87 = Tfa98xx_SetSampleRate(handlesIn[idx],
                    tfaParams.profile[profile].sampleRate); //TODO  we need to mute here
            PrintAssert(err87);
           //  Amplifier mute = soft mute + disabling amp at zero crossing of the pilot.
            err87 = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Amplifier);
            PrintAssert(err87);
            // i2s input route
            sysctrlReg = tfa98xxReadRegister( 9, handlesIn); // bit13 = intf_sel 0=in1 1=in2
            switch (tfaParams.profile[profile].i2sRoute)
            {
            case 1:
                sysctrlReg &= ~(0x1<<13);
                break;
            case 2:
                sysctrlReg |= (0x1<<13);
                break;
            default:
                break;
            }
            tfa98xxWriteRegister( 9, sysctrlReg, handlesIn);
            // TODO check if need to Tfa98xx_SelectChannel depending on i2s signal
            //  wait 20ms (which is more than enough for all use cases), or poll engaged bit.
            usleep(20000);
            //
            err87 = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Off);
            PrintAssert(err87);
         }
        // load the new preset
        err = tfa98xxSetParams(tfa_preset_params,
                tfaParams.profile[nxpTfaCurrentProfile].vstep[step].CF,
                TFA98XX_PRESET_LENGTH, handlesIn[idx]);
        if (tfa98xx_verbose)
            tfa98xxShowProfile(profile);
    }
    nxpTfa98xxSetVolumeDB(handlesIn, tfaParams.profile[profile].vstep[step].attenuation);
    err87 = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Off);

    PrintAssert(err87);

    nxpTfaCurrentProfile = profile;

    TRACEOUT

    return err;
}
/*
 * write all stored parameters to the DSP
 */
nxpTfa98xx_Error_t tfa98xxLoadParams(Tfa98xx_handle_t handle)
{
    Tfa98xx_Error_t err87;

    TRACEIN

    if (tfaParams.patchLength) {
        if(!tfa98xxSetParams(tfa_patch_params, (void*) tfaParams.patchBuffer,
                tfaParams.patchLength, handle))
            return nxpTfa98xx_Error_BadParam;
    }
    if (tfaParams.configLength) {
        if (!tfa98xxSetParams(tfa_config_params, (void*) tfaParams.configBuffer,
                tfaParams.configLength, handle))
            return nxpTfa98xx_Error_BadParam;
    }
    if (tfaParams.speakerLength) {
        if (!tfa98xxSetParams(tfa_speaker_params, tfaParams.speakerBuffer,
                tfaParams.speakerLength, handle))
            return nxpTfa98xx_Error_BadParam;
    }
    if (tfaParams.profile[nxpTfaCurrentProfile].valid ) {
      if (!tfa98xxSetParams(tfa_preset_params, tfaParams.profile[nxpTfaCurrentProfile].vstep[0].CF ,
                TFA98XX_PRESET_LENGTH, handle))
      {
            return nxpTfa98xx_Error_BadParam;
      }
      err87 = Tfa98xx_SetVolume( handle, tfaParams.profile[nxpTfaCurrentProfile].vstep[0].attenuation );
    }

    TRACEOUT

    return nxpTfa98xx_Error_Ok;

}

/*
 *
 */
void tfa98xxShowProfile( int profile)
{
    printf("profile[%d]: vsteps=%d, i2sRoute=%d, sampleRate=%d\n",
        profile, tfaParams.profile[profile].vsteps,
        tfaParams.profile[profile].i2sRoute,
        tfaParams.profile[profile].sampleRate);
}

/*
 * check what kind of preset file version we have here
 *   if old/single
 *     load a single vstep @step0
 *       assume volume=0
 *       cache the preset data
 */
nxpTfa98xx_Error_t nxpTfa98xxStoreProfile(int profile, void *data, int length) {
    nxpTfa98xx_Error_t err = nxpTfa98xx_Error_Ok;
    char *ptr = data;
    int step,steps;
    nxpTfa98xxVolumeStepFile_t *stepfile;

    TRACEIN

    // cleanup first, not needed
    //bzero(&tfaParams.profile[profile], sizeof(nxpTfa98xxProfile_t)); //TODO if error current is lost

    if (0 == strncmp(TFA_VSTEP_ID, ptr, 6)) { // it's a new type
    // TODO crc checking ! corrupt file may crash now
        stepfile = (nxpTfa98xxVolumeStepFile_t *) data;
        steps = stepfile->size / sizeof(nxpTfa98xxVolumeStep_t);

        if (steps >= TFA_MAX_VSTEPS) {
            fprintf(stderr, "too many volumesteps:%d, clipped to %d\n", steps, TFA_MAX_VSTEPS-1);
            //  return nxpTfa98xx_Error_BadParam; //
            steps = TFA_MAX_VSTEPS-1;
        }
        tfaParams.profile[profile].vsteps = steps;
        // copy data
        for (step = 0; step < tfaParams.profile[profile].vsteps; step++) {
            // load it
            tfaParams.profile[profile].vstep[step].attenuation = stepfile->vstep[step].attenuation ;
//          ptr=&stepfile->vstep[step].attenuation;
//          printf(" att steps file=%02x %02x %02x %02x, %f\n" , ptr[3], ptr[2], ptr[1], ptr[0],
//                              tfaParams.profile[profile].vstep[step].attenuation );
            memcpy(tfaParams.profile[profile].vstep[step].CF, stepfile->vstep[step].CF, TFA98XX_PRESET_LENGTH);
        }

    } else { // old single file
        step = 0;   // only step 0
        tfaParams.profile[profile].vsteps = 1; // only one
        tfaParams.profile[profile].vstep[step].attenuation = 0; // default TODO default att. ok?
        // copy data
        if (TFA98XX_PRESET_LENGTH != length) // double check
            return nxpTfa98xx_Error_BadParam;
        memcpy(tfaParams.profile[profile].vstep[step].CF, data,
                TFA98XX_PRESET_LENGTH);
    }

    // set hardcoded values
    tfaParams.profile[profile].i2sRoute = predefI2sRoute[profile]; // TODO define
    tfaParams.profile[profile].sampleRate = predefSampleRate[profile]; // TODO define
    tfaParams.profile[profile].valid=1;

    if (tfa98xx_verbose)
        tfa98xxShowProfile(profile);

    TRACEOUT

    return err;
}

/*
 * cache the parameter data into local memory
 */
nxpTfa98xx_Error_t nxpTfa98xxStoreParameters(Tfa98xx_handle_t *handlesIn, nxpTfa98xxParamsType_t params, void *data, int length )
{
    nxpTfa98xx_Error_t err = nxpTfa98xx_Error_Ok;

    TRACEIN

    /*
     * call the specific setter functions
     *  rely on the API for error checking
    */
    switch ( params )
    {
      case tfa_patch_params:
         tfaParams.patchLength = length;
         if  ( length > (int)sizeof(tfaParams.patchBuffer) )
            return nxpTfa98xx_Error_BadParam;
         memcpy( (void*)  tfaParams.patchBuffer, data, length);
         break;
      case tfa_config_params:
         tfaParams.configLength = length;
         if  ( length > (int)sizeof(tfaParams.configBuffer) )
            return nxpTfa98xx_Error_BadParam;
         memcpy( (void*) tfaParams.configBuffer, data, length);
         break;
      case tfa_speaker_params:
         tfaParams.speakerLength = length;
         if  ( length > (int)sizeof(tfaParams.speakerBuffer) )
            return nxpTfa98xx_Error_BadParam;
         memcpy( tfaParams.speakerBuffer, data, length);
         break;
      case tfa_preset_params:
         err= nxpTfa98xxStoreProfile(nxpTfaCurrentProfile, data, length); // loads single or multi presets
         break;
      case tfa_equalizer_params:
         printf("writing equalizer settings to device\n");
         err = tfa98xxSetEqualizer(handlesIn[idx], (const char *) data);
         PrintAssert(err);
         //actualLength = err ? 0 : TFA98XX_BIQUAD_LENGTH;
         break;
      default:
         fprintf(stderr, "%s Error: bad parameter:%d\n", __FUNCTION__, params) ;
         return nxpTfa98xx_Error_BadParam;
         break;
    }

    TRACEOUT

    return err;
}

/*
 * invalidate the parameter data from local memory
 */
void tfa98xxDeleteParams( nxpTfa98xxParamsType_t param )
{
    TRACEIN

    tfaParams.patchLength = 0;
    tfaParams.configLength = 0;
    tfaParams.speakerLength = 0;

    TRACEOUT


}
/*
 *
 */
int tfa98xxSetParams(   nxpTfa98xxParamsType_t params, void *data, int length,
                        Tfa98xx_handle_t handle)
{
   Tfa98xx_Error_t err;
   int actualLength = 0;

   TRACEIN

   if( handle == -1 )
   {
      return Tfa98xx_Error_NotOpen;
   }
   /*
    * call the specific setter functions
    *  rely on the API for error checking
   */
   switch ( params )
   {
      case tfa_patch_params:
         err = Tfa98xx_DspPatch(handle, length, (const unsigned char *) data);
         PrintAssert(err);
         actualLength = err ? 0 : length;
         break;
      case tfa_speaker_params:
         err = Tfa98xx_DspWriteSpeakerParameters(handle, TFA98XX_SPEAKERPARAMETER_LENGTH, (unsigned char *) data );
         PrintAssert(err);
         actualLength = err ? 0 : TFA98XX_SPEAKERPARAMETER_LENGTH;
         break;
      case tfa_config_params:
         err = Tfa98xx_DspWriteConfig(handle, TFA98XX_CONFIG_LENGTH, (const unsigned char *) data );
         PrintAssert(err);
         actualLength = err ? 0 : TFA98XX_CONFIG_LENGTH;
         break;
      case tfa_preset_params:
         err = Tfa98xx_DspWritePreset(handle, TFA98XX_PRESET_LENGTH, ( unsigned char *) data );
         PrintAssert(err);
         actualLength = err ? 0 : TFA98XX_PRESET_LENGTH;
         break;
      case tfa_equalizer_params:
         err = tfa98xxSetEqualizer(handle, (const char *) data);
         PrintAssert(err);
         actualLength = err ? 0 : Tfa98xx_BIQUAD_LENGTH;
         break;
      default:
         fprintf(stderr, "%s Error: bad parameter:%d\n", __FUNCTION__, params) ;
         actualLength = 0;
         break;
    }
    if ( (actualLength!=0) && (tfa98xx_quiet==0) )
      printf("written %s data to device\n", paramsName[params]);

    TRACEOUT

    return actualLength;
}

/*
 * volume control
 *
 *  note that the get only operates on the selected device
 */
int nxpTfa98xxGetVolume( Tfa98xx_handle_t *handlesIn, float *getVol )
{
   Tfa98xx_Error_t err;
   float vol = 0;

   TRACEIN

   if (handlesIn[idx] == -1)
   {
      err = Tfa98xx_Open(I2C, &handlesIn[idx]);
      PrintAssert( err);
      if (err)
      {
         return err;
      }

   }
   // call API
   err = Tfa98xx_GetVolume(handlesIn[idx], &vol);
   PrintAssert( err);
   if (err)
   {
      return err;
   }

   *getVol = vol;

   TRACEOUT

   return err;
}

int nxpTfa98xxSetVolumeDB( Tfa98xx_handle_t *handlesIn, float volume )
{
   Tfa98xx_Error_t err;

   TRACEIN

   if (handlesIn[idx] == -1)
   {
      err = Tfa98xx_Open(I2C, &handlesIn[idx]);
      PrintAssert( err);
      if ( err ) return err;

   }

   err = Tfa98xx_SetVolume(handlesIn[idx], volume);
//      err = Tfa98xx_SetVolume(handle[idx], (float) vol / (float) 10);
   PrintAssert( err);

   TRACEOUT

   return err;
}

/*
 *
 */
void tfa98xxPowerUp(Tfa98xx_handle_t *handlesIn)
{
    Tfa98xx_Error_t err;

    TRACEIN

    if (handlesIn[idx] == -1)
    {
       err = Tfa98xx_Open(I2C, &handlesIn[idx]);
       PrintAssert( err);
       if (err) return ;

    }
    // call API
    err = Tfa98xx_Powerdown(handlesIn[idx], 0);
    PrintAssert( err);

    TRACEOUT
}

/*
 *
 */
void tfa98xxPowerdown(Tfa98xx_handle_t *handlesIn   )
{
    Tfa98xx_Error_t err;

    TRACEIN

    if (handlesIn[idx] == -1)
    {
       err = Tfa98xx_Open(I2C, &handlesIn[idx]);
       PrintAssert( err);
       if (err) return ;

    }
    // call API
    err = Tfa98xx_Powerdown(handlesIn[idx], 1);
    PrintAssert( err);

    TRACEOUT

}
/*
 * note that this only operates on the selected device
 */
int tfa98xxGetCalibrationImpedance( float* re0, Tfa98xx_handle_t *handlesIn   )
{
    Tfa98xx_Error_t err;

    TRACEIN

    if (handlesIn[idx] == -1) {
        err = Tfa98xx_Open(I2C, &handlesIn[idx]);
        PrintAssert( err);
        if ( err ) return err;

    }
    // call API
    err = Tfa98xx_DspGetCalibrationImpedance(handlesIn[idx], re0);
    PrintAssert( err);
    return err;

    TRACEOUT

    return err;
}

/*
 * wait until calibration impedance is ok
 *  operate on all devices that have a handle open
 */
static Tfa98xx_Error_t waitCalibrationDone(Tfa98xx_handle_t handle, float *pRe25)
{
   Tfa98xx_Error_t err;
   int calibrateDone = 0;
   int i = 0;
   unsigned short status;

   err = Tfa98xx_DspReadMem(handle, 231, 1, &calibrateDone);
   PrintAssert(err);
   while ((calibrateDone == 0) && (i<1000) )				// TODO protect loop with timeout?
   {
      err = Tfa98xx_DspReadMem(handle, 231, 1, &calibrateDone);
	   if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }
      i++;
   }
   /* in calibrate once mode the data must be saved in MTP, DSP unresponsive while this is happening
    *  Checking for the MTP BUSY bit in the statusregister can also be done*/
   do
	{
		usleep(10000);
		err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUS, &status);
		PrintAssert(err);

	} while ( (status & TFA98XX_STATUS_MTPB) == TFA98XX_STATUS_MTPB);
	PrintAssert( (status & TFA98XX_STATUS_MTPB));

	err = Tfa98xx_DspGetCalibrationImpedance(handle, pRe25);

   PrintAssert(err);

   return err;
}
int tfa98xxWaitCalibration(Tfa98xx_handle_t *handlesIn)
{
   int ok = true;
   float re0;
   Tfa98xx_Error_t err = Tfa98xx_Error_Other;
   int calibrateDone = 0;

   if (handlesIn[idx] >= 0)
   {
      waitCalibration(handlesIn[idx], &calibrateDone);
      if (calibrateDone)
      {
         err = Tfa98xx_DspGetCalibrationImpedance(handlesIn[idx],&re0);
      }
      else
      {
         re0 = 0;
      }
   }

   return err;
}
/*
 * new calibration funtions
 */
float tCoefFromSpeaker(Tfa98xx_SpeakerParameters_t speakerBytes)
{
	int iCoef;

	/* tCoef(A) is the last parameter of the speaker */
	iCoef = (speakerBytes[TFA98XX_SPEAKERPARAMETER_LENGTH-3]<<16) + (speakerBytes[TFA98XX_SPEAKERPARAMETER_LENGTH-2]<<8) + speakerBytes[TFA98XX_SPEAKERPARAMETER_LENGTH-1];

	return (float)iCoef/(1<<23);
}

static void tCoefToSpeaker(Tfa98xx_SpeakerParameters_t speakerBytes, float tCoef)
{
	int iCoef;

	iCoef =(int)(tCoef*(1<<23));

	speakerBytes[TFA98XX_SPEAKERPARAMETER_LENGTH-3] = (iCoef>>16)&0xFF;
	speakerBytes[TFA98XX_SPEAKERPARAMETER_LENGTH-2] = (iCoef>>8)&0xFF;
	speakerBytes[TFA98XX_SPEAKERPARAMETER_LENGTH-1] = (iCoef)&0xFF;
}

/*
 * return current tCoef , set new value if arg!=0
 */
float tfa98xxTcoef(float tCoef)
{
    float current;

    current = tCoefFromSpeaker(tfaParams.speakerBuffer);

    if ( tCoef )
        tCoefToSpeaker(tfaParams.speakerBuffer, tCoef);

    return current;
}

static void coldboot_patch(Tfa98xx_handle_t handle){
const char coldboot[] = { 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x08, 0x00, 0x70, 0x00, 0x07, 0x81, 0x00, 0x00, 0x00, 0x01 };

	tfa98xxSetParams(tfa_patch_params, (void*) coldboot, sizeof(coldboot), handle);
}
static void coldStartup(Tfa98xx_handle_t handle)
{
	Tfa98xx_Error_t err;
	unsigned short status;

	/* load the optimal TFA98XX in HW settings */
	err = Tfa98xx_Init(handle);
	PrintAssert(err);

	err = Tfa98xx_SetSampleRate(handle, TFA_PROFILE0_SAMPLERATE); //TODO which samplerate?
	PrintAssert(err);

	err = Tfa98xx_Powerdown(handle, 0);
	PrintAssert(err);

	coldboot_patch(handle);

	err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUS, &status);
	PrintAssert(err);

	if ( !(status & TFA98XX_STATUS_ACS))
   {
      printf("Not Cold booted");
      return;  /* ensure cold booted */
   }

	/* cold boot, need to load all parameters and patches */
	/* patch the ROM code */
	if (tfaParams.patchLength) // only load if hwe have it
		tfa98xxSetParams(tfa_patch_params, (void*) tfaParams.patchBuffer,
            tfaParams.patchLength, handle);

}
/*
 *
 */
/*
 *  calculate a new tCoefA and put the result into the loaded Speaker params
 */
static Tfa98xx_Error_t calculateSpeakertCoefA(  Tfa98xx_handle_t handle,
                                                Tfa98xx_SpeakerParameters_t loadedSpeaker,
                                                float tCoef )
{
    Tfa98xx_Error_t err;
    float re25, tCoefA;
    int Tcal; /* temperature at which the calibration happened */
    int T0;
    int calibrateDone = 0;

    err = Tfa98xx_DspGetCalibrationImpedance(handle, &re25);
    PrintAssert(err);
    printf("re25 = %f\n", re25);

    /* use dummy tCoefA, also eases the calculations, because tCoefB=re25 */
    tCoefToSpeaker(loadedSpeaker, 0.0f);
 //   load_all_settings(handle, loadedSpeaker, LOCATION_FILES "RefSettings_v2.config", LOCATION_FILES "RefPreset_v2.Donau.preset");
    tfa98xxLoadParams(handle);
    printf("tCoef = %f\n", tCoef);
    /* start calibration and wait for result */
    err = Tfa98xx_SetConfigured(handle);
    if (err != Tfa98xx_Error_Ok)
    {
       return err;
    }

    waitCalibration(handle, &calibrateDone);
    if (calibrateDone)
    {
      err = Tfa98xx_DspGetCalibrationImpedance(handle, &re25);
    }
    else
    {
       re25 = 0;
    }
    err = Tfa98xx_DspReadMem(handle, 232, 1, &Tcal);
    if (err != Tfa98xx_Error_Ok)
    {
       return err;
    }
    printf("Calibration value is %2.2f ohm @ %d degress\n", re25, Tcal);

    /* calculate the tCoefA */
    T0 = 25; /* definition of temperature for Re0 */
    tCoefA = tCoef * re25 / (tCoef * (Tcal - T0)+1); /* TODO: need Rapp influence */
    printf("Final tCoefA %1.5f\n", tCoefA);

    /* update the speaker model */
    tCoefToSpeaker(loadedSpeaker, tCoefA);

    /* !!! the host needs to save this loadedSpeaker as it is needed after the next cold boot !!! */

    return err;
}

static Tfa98xx_Error_t CalibrationAlways(Tfa98xx_handle_t handle)
{
    Tfa98xx_Error_t err;
    unsigned short mtp, status;

    err = Tfa98xx_WriteRegister16(handle, 0x0B, 0x5A); /* unlock key2 */
    if (err != Tfa98xx_Error_Ok)
    {
       return err;
    }

    /* Read MTP Register  */
    err = Tfa98xx_ReadRegister16(handle, TFA98XX_MTP, &mtp);
    if (err != Tfa98xx_Error_Ok)
    {
       return err;
    }

    // if mtp=0 then it already set to calibration always, so skip
    if ( mtp!=0)
    {
        err = Tfa98xx_WriteRegister16(handle, TFA98XX_MTP, 0); /* MTPOTC=0, MTPEX=0 */
        if (err != Tfa98xx_Error_Ok)
         {
            return err;
         }
        err = Tfa98xx_WriteRegister16(handle, TFA98XX_MTP_COPY, 1<<11); /* CIMTP=1 */
        if (err != Tfa98xx_Error_Ok)
         {
            return err;
         }
        // note writing MPT to 0 takes long
        usleep(140000); // wait 140000ms for mtp to complete
        // polling status for MTP busy clear
        for(;;){
            usleep(10000); // wait 10ms for mtp to complete
            err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUSREG, &status);
            if ( status & (1<<8))
                ;//printf("0=%0x\n",status);
            else break;
        }
   }
   return err;

}

static int checkMTPEX(Tfa98xx_handle_t handle)
{
	unsigned short mtp;
	Tfa98xx_Error_t err;
	err = Tfa98xx_ReadRegister16(handle, TFA98XX_MTP, &mtp);
   if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }

   if ( mtp & (1<<1))	/* check MTP bit1 (MTPEX) */
		return 1;					/* MTPEX is 1, calibration is done */
	else
		return 0;					/* MTPEX is 0, calibration is not done yet */
}

static Tfa98xx_Error_t muteAmplifier(Tfa98xx_handle_t handle)
{
	Tfa98xx_Error_t err;
	unsigned short status;
   int tries = 0;

	/* signal the TFA98XX to mute plop free and turn off the amplifier */
	err = Tfa98xx_SetMute(handle, Tfa98xx_Mute_Amplifier);
	if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }

	/* now wait for the amplifier to turn off */
	err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUSREG, &status);
	if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }
	while ( ((status & TFA98XX_STATUS_SWS) == TFA98XX_STATUS_SWS) && (tries < 1000))
	{
		err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUSREG, &status);
      tries++;
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }
	}
   if (tries == 1000)
   {
      /*The amplifier is always switching*/
      return Tfa98xx_Error_Other;
   }

   return err;
}
/*
 * wait for mtpex to set
 */
int waitCalibration(Tfa98xx_handle_t handle, int *calibrateDone)
{
	Tfa98xx_Error_t err;
	int loop=1000;
	int tries = 0;
	unsigned short mtp;
#define WAIT_TRIES 1000

	err = Tfa98xx_ReadRegister16(handle, TFA98XX_MTP, &mtp);

	/* in case of calibrate once wait for MTPEX */
	if ( mtp & TFA98XX_MTP_MTPOTC) {
		while ( (*calibrateDone == 0) && (tries < TFA98XX_API_WAITRESULT_NTRIES))
		{	// TODO optimise with wait estimation
			err = Tfa98xx_ReadRegister16(handle, TFA98XX_MTP, &mtp);
			*calibrateDone = ( mtp & TFA98XX_MTP_MTPEX);	/* check MTP bit1 (MTPEX) */
			tries++;
		}
	} else /* poll xmem for calibrate always */
	{
		while ((*calibrateDone == 0) && (tries<WAIT_TRIES) )
		{	// TODO optimise with wait estimation
			err = Tfa98xx_DspReadMem(handle, 231, 1, calibrateDone);
			tries++;
		}
		if(tries==WAIT_TRIES)
			printf("calibrateDone 231 timedout\n");
	}

	return err;
}
static void ClearCalMtp(Tfa98xx_handle_t handle)
{
       Tfa98xx_Error_t err;
  unsigned short mtp, status;

       /* Read MTP Register  */
       err = Tfa98xx_ReadRegister16(handle, TFA98XX_MTP, &mtp);
       if (err != Tfa98xx_Error_Ok)
      {
         return;
      }


       /* Clear if non-0.*/
       if ( (mtp & TFA98XX_MTP_MTPOTC) != 0)
       {
              err = Tfa98xx_WriteRegister16(handle, 0x0B, 0x5A); /* unlock key2 */
              if (err != Tfa98xx_Error_Ok)
              {
                  return;
              }

              err = Tfa98xx_WriteRegister16(handle, TFA98XX_MTP, 0); /* MTPOTC=0, MTPEX=0 */
              if (err != Tfa98xx_Error_Ok)
              {
                  return;
              }
              err = Tfa98xx_WriteRegister16(handle, TFA98XX_MTP_COPY, 1<<11); /* CIMTP=1 */
              if (err != Tfa98xx_Error_Ok)
              {
                  return;
              }
              // polling status for MTP busy clear
              for(;;){
                  usleep(10000); // wait 1ms for mtp to complete
                  err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUSREG, &status);
                  if ( status & (1<<8))
                      ;//printf("0=%0x\n",status);
                  else break;
              }
       }
}

Tfa98xx_Error_t resetMtpEx(Tfa98xx_handle_t *handlesIn)
{
	Tfa98xx_Error_t err;
   unsigned short mtp;
	unsigned short status;

   if( handlesIn[idx] == -1)
   {
     err = Tfa98xx_Open(I2C, &handlesIn[idx] );
	  PrintAssert( err);
   }

	err = Tfa98xx_ReadRegister16(handlesIn[idx], TFA98XX_MTP, &mtp);
	if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }
	/* all settings loaded, signal the DSP to start calibration, only needed once after cold boot */

	/* reset MTPEX bit if needed */
	if ( (mtp & TFA98XX_MTP_MTPOTC) && (mtp & TFA98XX_MTP_MTPEX))
	{
		err = Tfa98xx_WriteRegister16(handlesIn[idx], 0x0B, 0x5A); /* unlock key2 */
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }

		err = Tfa98xx_WriteRegister16(handlesIn[idx], TFA98XX_MTP, 1); /* MTPOTC=1, MTPEX=0 */
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }
		err = Tfa98xx_WriteRegister16(handlesIn[idx], 0x62, 1<<11); /* CIMTP=1 */
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }
	}
	do
	{
		usleep(10000);
		err = Tfa98xx_ReadRegister16(handlesIn[idx], TFA98XX_STATUS, &status);
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }

	} while ( (status & TFA98XX_STATUS_MTPB) == TFA98XX_STATUS_MTPB);
	if (err != Tfa98xx_Error_Ok)
   {
         return err;
   }
   return err;
}

static Tfa98xx_Error_t resetMtpExLocal(Tfa98xx_handle_t handle)
{
	Tfa98xx_Error_t err;
   unsigned short mtp;
	unsigned short status;

	err = Tfa98xx_ReadRegister16(handle, TFA98XX_MTP, &mtp);
	if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }
	/* all settings loaded, signal the DSP to start calibration, only needed once after cold boot */

	/* reset MTPEX bit if needed */
	if ( (mtp & TFA98XX_MTP_MTPOTC) && (mtp & TFA98XX_MTP_MTPEX))
	{
		err = Tfa98xx_WriteRegister16(handle, 0x0B, 0x5A); /* unlock key2 */
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }

		err = Tfa98xx_WriteRegister16(handle, TFA98XX_MTP, 1); /* MTPOTC=1, MTPEX=0 */
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }
		err = Tfa98xx_WriteRegister16(handle, 0x62, 1<<11); /* CIMTP=1 */
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }
	}
	do
	{
		usleep(10000);
		err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUS, &status);
		if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }

	} while ( (status & TFA98XX_STATUS_MTPB) == TFA98XX_STATUS_MTPB);
	if (err != Tfa98xx_Error_Ok)
   {
         return err;
   }
   return err;
}

static Tfa98xx_Error_t Set_CalibrateOnce(Tfa98xx_handle_t handle)
{
       Tfa98xx_Error_t err;
  unsigned short mtp, status;

       /* Read MTP Register  */
       err = Tfa98xx_ReadRegister16(handle, TFA98XX_MTP, &mtp);
       if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }

       /* all settings loaded, signal the DSP to start calibration, only needed once after cold boot */

       /* Verify if device is already set to calibrate once.*/
       if ( (mtp & TFA98XX_MTP_MTPOTC) == 0)
       {
              err = Tfa98xx_WriteRegister16(handle, 0x0B, 0x5A); /* unlock key2 */
              if (err != Tfa98xx_Error_Ok)
               {
                  return err;
               }

              err = Tfa98xx_WriteRegister16(handle, TFA98XX_MTP, 1); /* MTPOTC=1, MTPEX=0 */
              if (err != Tfa98xx_Error_Ok)
               {
                  return err;
               }
              err = Tfa98xx_WriteRegister16(handle, TFA98XX_MTP_COPY, 1<<11); /* CIMTP=1 */
              if (err != Tfa98xx_Error_Ok)
               {
                  return err;
               }
              // polling status for MTP busy clear
              for(;;){
                  usleep(10000); // wait 1ms for mtp to complete
                  err = Tfa98xx_ReadRegister16(handle, TFA98XX_STATUSREG, &status);
                  if ( status & (1<<8))
                      ;//printf("0=%0x\n",status);
                  else break;
              }
       }
       return err;
}

static int dspSupporttCoef(Tfa98xx_handle_t handle)
{
	Tfa98xx_Error_t err;
	int bSupporttCoef;

	err = Tfa98xx_DspSupporttCoef(handle, &bSupporttCoef);
	assert(err == Tfa98xx_Error_Ok);

	return bSupporttCoef;
}

static int firstTimeCalibration(Tfa98xx_handle_t *handlesIn, int once)
{
   float tCoef, re25;
   Tfa98xx_Error_t err;

   coldStartup(handlesIn[idx]); 	 //TODO multiple calib?

   tCoef = tCoefFromSpeaker(tfaParams.speakerBuffer);

   printf("tCoef = %1.5f\n", tCoef);
	if(checkMTPEX(handlesIn[idx]) == 0)
   {

      printf("DSP not yet calibrated.\n");
      /* ensure no audio during special calibration */
      err = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Digital);
      assert(err == Tfa98xx_Error_Ok);
      if (!dspSupporttCoef(handlesIn[idx]))
      {
    	   printf(" 2 step calibration\n");
		   err = calculateSpeakertCoefA(handlesIn[idx], tfaParams.speakerBuffer, tCoef);
		   assert(err == Tfa98xx_Error_Ok);

		   /* if we were in one-time calibration (OTC) mode, clear the calibration results
		   from MTP so next time 2nd calibartion step can start. */
		   resetMtpEx(handlesIn);

		   /* force recalibration now with correct tCoefA */
		   muteAmplifier(handlesIn[idx]); /* clean shutdown to avoid plop */
		   coldStartup(handlesIn[idx]);
      }
	}
	else
	{
		printf("DSP already calibrated. Calibration skipped and previous calibration results loaded from MTP.\n");
	}

   if ( once )
   {
      Set_CalibrateOnce(handlesIn[idx]);
   }
   else
   {
      CalibrationAlways(handlesIn[idx]);
   }

   tfa98xxLoadParams(handlesIn[idx]);    // write all settings

   /* do calibration (again), if needed */
   err = Tfa98xx_SetConfigured(handlesIn[idx]);
   if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }
 //  waitCalibration(handlesIn[idx], &re25);
   err = Tfa98xx_DspGetCalibrationImpedance(handlesIn[idx],&re25);
   printf("Calibration value is %2.2f ohm\n", re25);

   //err = Tfa98xx_DspReadSpeakerParameters(handlesIn[idx], TFA98XX_SPEAKERPARAMETER_LENGTH, tfaParams.speakerBuffer);
   //tCoef = tCoefFromSpeaker(tfaParams.speakerBuffer);

   //printf("tCoefA = %1.5f\n", tCoef);

   return err;
}

int nxpTfa98xxCalibration(Tfa98xx_handle_t *handlesIn, int once)
{
	Tfa98xx_Error_t err = Tfa98xx_Error_Ok;

	if( handlesIn[0] == -1)
	{
		err = Tfa98xx_Open( tfa98xxI2cSlave*2, &handlesIn[0] );
		PrintAssert( err);
	}
	if (err == Tfa98xx_Error_Ok) {
		err = tfa98xxCalibration(handlesIn, 0, once);
		PrintAssert( err);
	}

	return err;
}

int nxpTfa98xxCalibrationStereo(Tfa98xx_handle_t *handlesIn, int once)
{
   float tCoef, re25;
   Tfa98xx_Error_t err = Tfa98xx_Error_Ok;
   int i = 0;
   int calibrateDone = 0;

   printf("calibrate %s\n", once ? "once" : "always" );

   tCoef = tCoefFromSpeaker(tfaParams.speakerBuffer);

   for (i = 0; i < 2; i++)
   {
      if( handlesIn[i] == -1)
      {
         err = Tfa98xx_Open(((tfa98xxI2cSlave+i)*2), &handlesIn[i] );
	      PrintAssert( err);
      }

      if ( err != Tfa98xx_Error_Ok )
      {
         return err;
      }

      coldStartup(handlesIn[i]); 	 //TODO multiple calib?

      printf("tCoef = %1.5f\n", tCoef);
      if(checkMTPEX(handlesIn[i]) == 0)
      {

         printf("DSP not yet calibrated.\n");
         /* ensure no audio during special calibration */
         err = Tfa98xx_SetMute(handlesIn[i], Tfa98xx_Mute_Digital);
         assert(err == Tfa98xx_Error_Ok);
         if (!dspSupporttCoef(handlesIn[i]))
         {
            printf("still tCoef in speaker file, special calibration needed\n");

            err = calculateSpeakertCoefA(handlesIn[i], tfaParams.speakerBuffer, tCoef);
            if (err != Tfa98xx_Error_Ok)
            {
               return err;
            };

            resetMtpExLocal(handlesIn[i]);
            /* force recalibration now with correct tCoefA */
		      err = muteAmplifier(handlesIn[i]); /* clean shutdown to avoid plop */
            PrintAssert( err);
            coldStartup(handlesIn[i]);
         }
      }

      if ( once )
      {
         Set_CalibrateOnce(handlesIn[i]);
      }
      else
      {
         CalibrationAlways(handlesIn[i]);
      }
   }
   tfa98xxSelectStereo(handlesIn);
   for (i = 0; i < 2; i++)
   {
      tfa98xxLoadParams(handlesIn[i]);    // write all settings

      /* do calibration (again), if needed */
      err = Tfa98xx_SetConfigured(handlesIn[i]);
      if (err != Tfa98xx_Error_Ok)
      {
         return err;
      }
      waitCalibration(handlesIn[i], &calibrateDone);
      if (calibrateDone)
      {
         err = Tfa98xx_DspGetCalibrationImpedance(handlesIn[i], &re25);
      }
      else
      {
         re25 = 0;
      }
      printf("Calibration value is %2.2f ohm\n", re25);

      err = Tfa98xx_DspReadSpeakerParameters(handlesIn[i], TFA98XX_SPEAKERPARAMETER_LENGTH, tfaParams.speakerBuffer);
      tCoef = tCoefFromSpeaker(tfaParams.speakerBuffer);

      printf("tCoefA = %1.5f\n", tCoef);
   }
   return err;
}

/*
 * select device for testing and individual addressing
 *
 * this is for read/write
 */
int nxpTfa98xxSetIdx( int idxIn )
{
    int err = 0;

    if ( idxIn > 2) {
        fprintf(stderr, "%s Error: index %i bigger then max devices %i\n", __FUNCTION__, idx, 2) ;
        err = 1;
        return err;
    }
    idx = idxIn;

    return err;
}

/*
 * Bypass DSP handling
 */
int nxpTfa98xxBypassDSP(Tfa98xx_handle_t *handlesIn)
{
   Tfa98xx_Error_t err = Tfa98xx_Error_Other;
   unsigned short i2SRead = 0;

   TRACEIN

   // basic settings for quickset
   err = Tfa98xx_ReadRegister16( handlesIn[idx], 4, &i2SRead);

   i2SRead &= TFA_I2SCTRL_BYPASS_DSP;

   err = Tfa98xx_WriteRegister16( handlesIn[idx], 4, i2SRead );

   TRACEOUT

   return err;
}

/*
 * Unbypassed the DSP
 */
int nxpTfa98xxUnBypassDSP(Tfa98xx_handle_t *handlesIn)
{
   Tfa98xx_Error_t err = Tfa98xx_Error_Other;
   unsigned short i2SRead = 0;

   TRACEIN

   // basic settings for quickset
   err = Tfa98xx_ReadRegister16( handlesIn[idx], 4, &i2SRead);

   i2SRead |= TFA_I2SCTRL_UNBYPASS_DSP;

   err = Tfa98xx_WriteRegister16( handlesIn[idx], 4, i2SRead );

   TRACEOUT

   return err;
}

/*
 * Set sample rate;
 * @param rate in Hz.  must be 32000, 44100 or 48000
 */
nxpTfa98xx_Error_t nxpTfa98xxSetSampleRate(Tfa98xx_handle_t *handlesIn, int rate)
{
   Tfa98xx_Error_t err = Tfa98xx_Error_Other;

   TRACEIN
   if( handlesIn[idx] == -1)
   {
      err = Tfa98xx_Open(I2C, &handlesIn[idx] );
      PrintAssert( err);
      if (err) return (nxpTfa98xx_Error_t) err;
   }

   tfaParams.profile[0].sampleRate = rate;

   // basic settings for quickset
   err = Tfa98xx_SetSampleRate(handlesIn[idx], rate);

   TRACEOUT

   return (nxpTfa98xx_Error_t)err;
}

/*
 * Get sample rate;
 * @param rate in Hz.  must be 32000, 44100 or 48000
 */
nxpTfa98xx_Error_t nxpTfa98xxGetSampleRate(Tfa98xx_handle_t *handlesIn, int *pRate)
{
   Tfa98xx_Error_t err = Tfa98xx_Error_Other;

   TRACEIN

   // basic settings for quickset
   err = Tfa98xx_GetSampleRate(handlesIn[idx], pRate);

   TRACEOUT

   return (nxpTfa98xx_Error_t)err;
}

/*
 * operates only on selected dev
 */
int tfa98xxGetState(float* resistance, float* temperature, Tfa98xx_handle_t *handlesIn )
{
    Tfa98xx_Error_t err;
    Tfa98xx_StateInfo_t info;

    TRACEIN

    if (handlesIn[idx] == -1) {
        err = Tfa98xx_Open(I2C, &handlesIn[idx]);
        PrintAssert( err);
        if (err) return err;
    }

    err = Tfa98xx_DspGetStateInfo(handlesIn[idx], &info);
    PrintAssert( err);

    if (err == Tfa98xx_Error_Ok) {
        *resistance = info.Re;
        *temperature = info.T;
    }
    TRACEOUT

    return err;
}

/*
 * read a register
 */
unsigned short tfa98xxReadRegister(unsigned char offset, Tfa98xx_handle_t *handlesIn   )
{
    Tfa98xx_Error_t err;
    unsigned short value;

    TRACEIN

    if( handlesIn[idx] == -1) {
        err = Tfa98xx_Open(I2C, &handlesIn[idx] );
        PrintAssert( err);
        if (err) return err;

    }

    err = Tfa98xx_ReadRegister16( handlesIn[idx] , offset, &value);
    PrintAssert( err);

    TRACEOUT

    return value;

}
/*
 * read a register
 */
unsigned int tfa98xxReadXmem(unsigned char offset, Tfa98xx_handle_t *handlesIn   )
{
    Tfa98xx_Error_t err;
    int value;

    TRACEIN

    if( handlesIn[idx] == -1) {
        err = Tfa98xx_Open(I2C, &handlesIn[idx] );
        PrintAssert( err);
        if (err) return err;

    }
    err = Tfa98xx_DspReadMem(handlesIn[idx] , offset, 1, &value);
    PrintAssert( err);

    TRACEOUT

    return value & 0xffffff;

}
/*
 * write a register
 */
void tfa98xxWriteRegister( unsigned char offset, unsigned short value,
                           Tfa98xx_handle_t *handlesIn   )
{
    Tfa98xx_Error_t err;

    TRACEIN

    if( handlesIn[idx] == -1) {
        err = Tfa98xx_Open(I2C, &handlesIn[idx] );
        PrintAssert( err);
        if (err) return ;

    }

    err = Tfa98xx_WriteRegister16( handlesIn[idx] , offset, value);
    PrintAssert( err);

    TRACEOUT

}

/*
 * get tag
 *
 */
static nxpTfa98xx_Error_t nxpTfa98xx_GetDspTag(Tfa98xx_handle_t *handlesIn, char *string, int *size)
{
    Tfa98xx_Error_t err87;
    nxpTfa98xx_Error_t err = nxpTfa98xx_Error_Ok;
    int i;
    char tag[TFA98XX_MAXTAG];

    *size = 0;

    // interface should already be opened
    err87 = Tfa98xx_DspGetParam(handlesIn[idx], 1 /*MODULE_SPEAKERBOOST*/ , 0xFF,
            TFA98XX_MAXTAG, tag);

    PrintAssert( err87);

    if (err87 == Tfa98xx_Error_Ok) {
        // the characters are in every 3rd byte
        for ( i=2 ; i<TFA98XX_MAXTAG ; i+=3)
        {
                if ( isprint(tag[i]) ) {
                    *string++ =  tag[i];    // only printable chars
                    (*size)++;
                }
        }
         *string = '\0';
    }
    if (err87 == Tfa98xx_Error_DSP_not_running)
        return nxpTfa98xx_Error_DSP_not_running;
    else if (err87 == Tfa98xx_Error_Bad_Parameter)
        return nxpTfa98xx_Error_BadParam;

    return err;
}

/*
 * return version strings
 */
nxpTfa98xx_Error_t nxpTfa98xxVersions( Tfa98xx_handle_t *handlesIn, char *strings, int maxlength )
{
	nxpTfa98xx_Error_t err = nxpTfa98xx_Error_Ok;
    Tfa98xx_Error_t err87;
    char str[NXPTFA_MAXLINE],str1[NXPTFA_MAXLINE];
    int length=0, i;
    unsigned short reg;

    // API rev
    sprintf(str, "nxpTfa API rev: %d.%d\n", NXPTFA_APP_REV_MAJOR, NXPTFA_APP_REV_MINOR);
    length = strlen(str);

    if (  length > maxlength )
        return nxpTfa98xx_Error_BadParam; // max length too short

    strcpy(strings, str);
    strings += length;
    length  += length;

    // tfa9887 API rev
#ifdef  TFA98XX_MTP_COPY		// the last version has this define, new will have a version number
    sprintf(str, "Tfa98xx API rev: 2.1\n");
#else
    sprintf(str, "Tfa98xx API rev: ??? TBS\n");
#endif
    length = strlen(str);

    if (  length > maxlength )
        return nxpTfa98xx_Error_BadParam; // max length too short

    strcpy(strings, str);
    strings += length;
    length  += length;
   // chip rev
    reg = tfa98xxReadRegister(0x03, handlesIn); //TODO define a rev somewhere
    sprintf(str, "Tfa98xx HW  rev: 0x%04x\n", reg);

    length = strlen(str);

    if (  length > maxlength )
        return nxpTfa98xx_Error_BadParam; // max length too short

    strcpy(strings, str);
    strings += length;
    length  += length;

//


    /* load the optimal TFA98XX in HW settings */
    err87 = Tfa98xx_Init(handlesIn[idx]);
    if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }

    err87 = Tfa98xx_SetSampleRate(handlesIn[idx], TFA_PROFILE0_SAMPLERATE); //TODO which samplerate?
    if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }

    err87 = Tfa98xx_Powerdown(handlesIn[idx], 0);
    if (err != Tfa98xx_Error_Ok)
   {
      return err;
   }
//
#if 1
    // coolflux ROM rev
    err = nxpTfa98xx_GetDspTag( handlesIn, str, &i);
    if ( err != nxpTfa98xx_Error_Ok)
        return err;
    length += i;

    if (  length > maxlength )
        return nxpTfa98xx_Error_BadParam; // max length too short
    sprintf(str1, "DSP revstring: \"%s\"\n", str);
    strcpy(strings, str1);
    strings += strlen(str1);
    length  += strlen(str1);
#endif
    *strings = '\0';

    return err;

}

/*
 * read DSP parameters
 */
nxpTfa98xx_Error_t tfa98xxDspGetParam( unsigned char module_id, unsigned char param_id,
                                       int num_bytes, unsigned char data[],
                                       Tfa98xx_handle_t *handlesIn    )
{
    Tfa98xx_Error_t err87;
    nxpTfa98xx_Error_t err = nxpTfa98xx_Error_Ok;

    TRACEIN

    if( handlesIn[idx] == -1) {
        err87 = Tfa98xx_Open(I2C, &handlesIn[idx] );
        PrintAssert( err87);
        if (err87) return err87;

    }

    err87 = Tfa98xx_DspGetParam(handlesIn[idx], module_id, param_id, num_bytes, data );
    PrintAssert( err87);

    if (err87 ==  Tfa98xx_Error_DSP_not_running)
    	err = nxpTfa98xx_Error_DSP_not_running;
    else if (err87 == Tfa98xx_Error_Bad_Parameter)
    	err = nxpTfa98xx_Error_BadParam;

    TRACEOUT

    return err;

}

/*
 * save params
 */
int tfa98xxSaveParamsFile(Tfa98xx_handle_t *handlesIn, char *filename)
{
      FILE *f;
      int c;

      f = fopen( filename, "wb");
      if (!f)
            {
                printf("Unable to open %s\n", filename);
                return 0;
            }
      c = fwrite( (void*)&tfaParams, sizeof(nxpTfa98xxParameters_t) , 1, f );
      fclose(f);

      return c;
}

/*
 * save dedicated params
 */
int tfa98xxSaveFile(Tfa98xx_handle_t *handlesIn, char *filename, nxpTfa98xxParamsType_t params)
{
   FILE *f;

   int c=0, i=0;
   unsigned char bytes[252] = {0};

   Tfa98xx_Error_t err;

   if( handlesIn[idx] == -1)
   {
      err = Tfa98xx_Open(I2C, &handlesIn[idx] );
      PrintAssert( err);
      if (err) return err;

   }

   /*
    * call the specific setter functions
    *  rely on the API for error checking
   */
   switch ( params )
   {
      case tfa_patch_params:
         break;
      case tfa_speaker_params:
         err = Tfa98xx_DspReadSpeakerParameters(handlesIn[idx], TFA98XX_SPEAKERPARAMETER_LENGTH, tfaParams.speakerBuffer);
         if (err)
         {
            printf("DSP error\n");
            return err;
         }
         PrintAssert(err);
         f = fopen( filename, "wb");
         if (!f)
         {
             printf("Unable to open %s\n", filename);
             err = Tfa98xx_Error_Other;
             return err;
         }
         c = fwrite( (void*)&tfaParams.speakerBuffer, TFA98XX_SPEAKERPARAMETER_LENGTH , 1, f );
         fclose(f);
         break;
      case tfa_config_params:
         err = Tfa98xx_DspReadConfig(handlesIn[idx], TFA98XX_CONFIG_LENGTH, tfaParams.configBuffer);
         if (err)
         {
            printf("DSP error\n");
            return err;
         }
         PrintAssert(err);
         f = fopen( filename, "wb");
         if (!f)
         {
            printf("Unable to open %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         c = fwrite( (void*)&tfaParams.configBuffer, TFA98XX_CONFIG_LENGTH , 1, f );
         fclose(f);
         break;
      case tfa_preset_params:
         err = Tfa98xx_DspReadPreset(  handlesIn[idx],
                                       TFA98XX_CONFIG_LENGTH+TFA98XX_PRESET_LENGTH,
                                       bytes );
         if (err)
         {
            printf("DSP error\n");
            return err;
         }
         for (i=0; i<TFA98XX_PRESET_LENGTH; i++)
         {
            tfaParams.profile[nxpTfaCurrentProfile].vstep[0].CF[i] = bytes[i+165];
         }
         PrintAssert(err);
         f = fopen( filename, "wb");
         if (!f)
         {
             printf("Unable to open %s\n", filename);
             err = Tfa98xx_Error_Other;
             return err;
         }
         c = fwrite( (void*)&tfaParams.profile[nxpTfaCurrentProfile].vstep[0].CF, TFA98XX_PRESET_LENGTH , 1, f );
         fclose(f);
         break;
      case tfa_equalizer_params:
         break;
      default:
         fprintf(stderr, "%s Error: bad parameter:%d\n", __FUNCTION__, params) ;
         break;
   }

   if (c != 1)
   {
      printf("Unable to handle the file %s\n", filename);
      err = Tfa98xx_Error_Other;
      return err;
   }

   return Tfa98xx_Error_Ok;
}

/*
 * Load dedicated params
 */
int tfa98xxLoadFile(Tfa98xx_handle_t *handlesIn, char *filename, nxpTfa98xxParamsType_t params)
{
   FILE *f;
   int c=0, i=0;
   unsigned char bytes[252] = {0};

   Tfa98xx_Error_t err;

   if( handlesIn[idx] == -1)
   {
      err = Tfa98xx_Open(I2C, &handlesIn[idx] );
      PrintAssert( err);
      if (err) return err;

   }

   /*
    * call the specific setter functions
    *  rely on the API for error checking
   */
   switch ( params )
   {
      case tfa_patch_params:
         f = fopen( filename, "rb");
         if (!f)
         {
            printf("Unable to open %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         c = fread( (void*)&tfaParams.patchBuffer, 1, tfaParams.patchLength, f );
         fclose(f);
         if (c != tfaParams.patchLength)
         {
            printf("Wrong patch size %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         break;
      case tfa_speaker_params:
         f = fopen( filename, "rb");
         if (!f)
         {
            printf("Unable to open %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         c = fread( (void*)&tfaParams.speakerBuffer, 1, TFA98XX_SPEAKERPARAMETER_LENGTH, f );
         fclose(f);
         if (c != TFA98XX_SPEAKERPARAMETER_LENGTH)
         {
            printf("Wrong speaker size %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         err = Tfa98xx_DspWriteSpeakerParameters(  handlesIn[idx],
                                                   TFA98XX_SPEAKERPARAMETER_LENGTH,
                                                   tfaParams.speakerBuffer);
         if (err)
         {
            printf("DSP error\n");
            return err;
         }
         break;
      case tfa_config_params:
         f = fopen( filename, "rb");
         if (!f)
         {
            printf("Unable to open %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         c = fread( (void*)&tfaParams.configBuffer, 1, TFA98XX_CONFIG_LENGTH, f );
         fclose(f);
         if (c != TFA98XX_CONFIG_LENGTH)
         {
            printf("Wrong config size %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         err = Tfa98xx_DspWriteConfig( handlesIn[idx],
                                       TFA98XX_CONFIG_LENGTH,
                                       tfaParams.configBuffer);
         if (err)
         {
            printf("DSP error\n");
            return err;
         }
         break;
      case tfa_preset_params:
         f = fopen( filename, "rb");
         if (!f)
         {
            printf("Unable to open %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         c = fread(  (void*)&tfaParams.profile[nxpTfaCurrentProfile].vstep[0].CF,
                     1, TFA98XX_PRESET_LENGTH, f );
         fclose(f);
         if (c != TFA98XX_PRESET_LENGTH)
         {
            printf("Wrong preset size %s\n", filename);
            err = Tfa98xx_Error_Other;
            return err;
         }
         err = Tfa98xx_DspWritePreset( handlesIn[idx],
                                       TFA98XX_PRESET_LENGTH,
                                       tfaParams.profile[nxpTfaCurrentProfile].vstep[0].CF);
         if (err)
         {
            printf("DSP error\n");
            return err;
         }
         break;
      case tfa_equalizer_params:
         break;
      default:
         fprintf(stderr, "%s Error: bad parameter:%d\n", __FUNCTION__, params) ;
         break;
   }

   return Tfa98xx_Error_Ok;
}
/*
 * load params
 */
int tfa98xxLoadParamsFile( Tfa98xx_handle_t *handlesIn, char *filename )
{
   FILE *f;
   int c;

   f = fopen( filename, "rb");
   if (!f)
   {
      printf("Unable to open %s\n", filename);
      return 0;
   }
   c = fread( (void*)&tfaParams, sizeof(nxpTfa98xxParameters_t) , 1, f );
   fclose(f);

   return c;
}

/*
 * Opening the device
 */
nxpTfa98xx_Error_t nxpTfa98xxOpen (Tfa98xx_handle_t *handlesIn)
{
   nxpTfa98xx_Error_t err = nxpTfa98xx_Error_Fail;

   err = (nxpTfa98xx_Error_t) Tfa98xx_Open(I2C, &handlesIn[idx] );

   if (err != nxpTfa98xx_Error_Ok)
   {
      return err;
   }

   return err;
}

/*
 * Opening the device
 */
int nxpTfa98xxClose (Tfa98xx_handle_t *handlesIn)
{
   Tfa98xx_Error_t err=Tfa98xx_Error_Ok;

   err = Tfa98xx_SetMute(handlesIn[idx], Tfa98xx_Mute_Amplifier);

   err = Tfa98xx_Powerdown(handlesIn[idx], true);

   err = Tfa98xx_Close( handlesIn[idx] );

   return err;
}

/*Default parameter setting, the contents from devkit_Release.parms*/
unsigned char devkit_parms[] = {
  0x56, 0x09, 0x00, 0x00, 0x12, 0x22, 0x10, 0x73, 0x33, 0x33, 0x03, 0x00,
  0x70, 0x00, 0x01, 0xfb, 0x00, 0x71, 0x40, 0x00, 0x38, 0x08, 0x0a, 0x6f,
  0x9b, 0xa6, 0x7d, 0x04, 0xb0, 0xb6, 0x62, 0x88, 0x69, 0x7e, 0xc4, 0x08,
  0x6a, 0xbf, 0x54, 0xfc, 0xb5, 0x00, 0x58, 0x7f, 0x3b, 0x80, 0x01, 0x25,
  0x30, 0x50, 0x00, 0x80, 0x69, 0x5e, 0xd4, 0x3c, 0x3a, 0x90, 0x00, 0x0d,
  0x72, 0x02, 0xc4, 0x80, 0x6a, 0xbe, 0xd4, 0x3e, 0x30, 0x40, 0x00, 0x80,
  0x3b, 0x80, 0x01, 0x00, 0xb0, 0xb2, 0xf6, 0x48, 0x6a, 0x5e, 0x54, 0x3e,
  0x3a, 0x80, 0x00, 0x80, 0x3b, 0x80, 0x01, 0x00, 0x9b, 0xa6, 0xf8, 0x49,
  0x39, 0x84, 0x80, 0x80, 0x92, 0x19, 0xfe, 0x9c, 0x3b, 0x62, 0x40, 0x1c,
  0x9b, 0x84, 0x54, 0x3d, 0x61, 0x40, 0x7e, 0x9c, 0x3b, 0x80, 0x07, 0xf1,
  0xa6, 0xb6, 0x7e, 0x9c, 0x3b, 0x00, 0x40, 0x21, 0xb5, 0x00, 0x58, 0x3f,
  0x3b, 0x80, 0x08, 0x00, 0x9b, 0xa4, 0x7e, 0x9c, 0x9b, 0xa4, 0x54, 0x3d,
  0xa5, 0xb2, 0xd8, 0x3f, 0xb5, 0x00, 0x42, 0xc0, 0x3c, 0xd8, 0x03, 0x00,
  0x8b, 0x80, 0x7d, 0x7c, 0xb5, 0x00, 0x7e, 0x9c, 0x9b, 0x86, 0x7d, 0x04,
  0x38, 0x0a, 0x0a, 0x6f, 0xb0, 0xb2, 0xd4, 0x7e, 0x6a, 0x7e, 0x52, 0xfd,
  0x71, 0x04, 0xd8, 0x7f, 0x3b, 0x80, 0x01, 0x25, 0x30, 0x50, 0x00, 0x80,
  0x69, 0x5e, 0xd5, 0x3e, 0x72, 0x02, 0xc4, 0x11, 0x6a, 0xbe, 0xd4, 0xbc,
  0x30, 0x40, 0x00, 0x80, 0x3b, 0x80, 0x01, 0x00, 0xb0, 0xb2, 0xf6, 0x00,
  0xb5, 0x00, 0x54, 0x3c, 0x3a, 0x88, 0x00, 0x80, 0xb5, 0x00, 0x54, 0x3d,
  0x3b, 0x80, 0x01, 0x00, 0x9b, 0xa6, 0xfe, 0x9c, 0xb5, 0x00, 0x58, 0x3f,
  0x3c, 0xd8, 0x03, 0x00, 0x8b, 0x80, 0x7d, 0x7c, 0xb5, 0x00, 0x7e, 0x9c,
  0x3a, 0x88, 0x00, 0x0a, 0x9b, 0x8c, 0x42, 0x88, 0xa6, 0x56, 0x7d, 0x05,
  0x39, 0x02, 0x22, 0x20, 0xfb, 0x00, 0x71, 0x40, 0x3e, 0xaa, 0x08, 0xc4,
  0x00, 0x3a, 0x89, 0x00, 0xa6, 0xba, 0x41, 0x58, 0x7b, 0xb5, 0x00, 0x5c,
  0x7d, 0x3b, 0x80, 0x13, 0x20, 0xba, 0x20, 0xda, 0x7c, 0x6d, 0x5e, 0x50,
  0xbd, 0x3a, 0x91, 0x00, 0x18, 0x82, 0x04, 0x7e, 0x50, 0x3a, 0x80, 0x00,
  0x29, 0x3a, 0x9a, 0xff, 0xfa, 0x38, 0x08, 0x0b, 0x68, 0x38, 0x0c, 0x0b,
  0x6d, 0xbf, 0x10, 0x42, 0x40, 0x38, 0x0d, 0x0b, 0x6a, 0xbb, 0x00, 0x4c,
  0x98, 0x6a, 0x3e, 0xd5, 0xfc, 0x31, 0x80, 0x20, 0xaf, 0x3b, 0x80, 0x01,
  0x07, 0x9b, 0xa2, 0xca, 0x48, 0x7f, 0x4e, 0x54, 0xbc, 0xb5, 0x00, 0x4c,
  0x88, 0x3a, 0x91, 0xff, 0x43, 0xb5, 0x00, 0x42, 0x90, 0x96, 0xf4, 0xd5,
  0x3d, 0x3a, 0x81, 0xff, 0x41, 0x61, 0x48, 0xfd, 0xa9, 0x3a, 0x88, 0x00,
  0xaf, 0x61, 0x8a, 0x72, 0xe8, 0x6a, 0x7e, 0xc4, 0x00, 0x30, 0x40, 0x00,
  0x80, 0x30, 0x70, 0x02, 0xbc, 0x3b, 0x80, 0x1c, 0x5a, 0xb5, 0x00, 0x55,
  0x7c, 0xb5, 0x00, 0x54, 0x3d, 0x3a, 0x88, 0x00, 0x0f, 0x62, 0x24, 0x44,
  0x0a, 0x3a, 0x91, 0xff, 0x4f, 0x30, 0x50, 0x00, 0x80, 0x3b, 0x80, 0x01,
  0x25, 0xb5, 0x00, 0x55, 0x7d, 0x6a, 0xde, 0x54, 0xbd, 0x3a, 0x81, 0xff,
  0xf3, 0x72, 0x22, 0xc2, 0x84, 0x30, 0xa0, 0x0a, 0x70, 0x61, 0x04, 0x42,
  0x98, 0x7f, 0x2c, 0x76, 0x91, 0x38, 0x0c, 0x22, 0x08, 0x60, 0x08, 0x43,
  0x48, 0x69, 0x3f, 0x54, 0x7d, 0xb5, 0x00, 0x52, 0xff, 0x3b, 0x80, 0x1b,
  0x5b, 0x38, 0x01, 0x0a, 0x6f, 0x30, 0x00, 0x00, 0x20, 0xb9, 0x00, 0x54,
  0x3d, 0x9b, 0x2b, 0x55, 0x3c, 0xb0, 0x04, 0x52, 0xbe, 0x38, 0x08, 0x22,
  0x01, 0xa6, 0xd0, 0x52, 0x3f, 0x3a, 0x80, 0x00, 0x0f, 0x8b, 0x80, 0x42,
  0x50, 0x9b, 0xa2, 0x42, 0xc0, 0xfb, 0x00, 0x71, 0x40, 0x7c, 0x3a, 0x88,
  0x00, 0xb4, 0xb5, 0x00, 0x53, 0x7c, 0x31, 0x1f, 0xff, 0xe9, 0x69, 0x3f,
  0x44, 0x0d, 0x3b, 0x80, 0x01, 0x25, 0xb5, 0x00, 0x54, 0xfd, 0x7f, 0x4e,
  0x54, 0x3d, 0xb5, 0x00, 0x44, 0x00, 0x3b, 0x80, 0x01, 0x25, 0x9b, 0xa7,
  0x7e, 0x9c, 0x7d, 0x8c, 0x54, 0x3d, 0x7c, 0x24, 0xc4, 0x85, 0x6a, 0x3e,
  0xd2, 0xbc, 0x61, 0x64, 0x44, 0x00, 0x3b, 0x80, 0x02, 0xe4, 0x30, 0x50,
  0x00, 0x80, 0x9b, 0xa2, 0x52, 0x3e, 0x90, 0x90, 0xd4, 0xbd, 0xa2, 0x12,
  0xfb, 0x24, 0xb5, 0x00, 0x4c, 0x8d, 0x3b, 0x44, 0x40, 0x7e, 0x31, 0x10,
  0x00, 0x1c, 0xb5, 0x00, 0x4c, 0xcd, 0xb5, 0x00, 0x58, 0x3b, 0x3c, 0xd8,
  0x03, 0x00, 0x8b, 0x80, 0x7d, 0x7b, 0xb5, 0x00, 0x7e, 0x9c, 0x6c, 0x3f,
  0xfd, 0x02, 0x3b, 0x80, 0x10, 0xa5, 0xb5, 0x00, 0x54, 0x7e, 0xb5, 0x00,
  0x54, 0x3e, 0x3a, 0x90, 0x00, 0x5c, 0x30, 0x40, 0x00, 0x82, 0x7f, 0x28,
  0xc2, 0x51, 0x3a, 0x9a, 0xff, 0xde, 0x3a, 0xa3, 0x00, 0x14, 0x30, 0x41,
  0x00, 0x00, 0x38, 0x10, 0x26, 0x91, 0x61, 0x2c, 0x7e, 0x50, 0x3a, 0x8c,
  0xff, 0xb3, 0x30, 0x05, 0x00, 0x00, 0x3b, 0x80, 0x0a, 0x71, 0xb5, 0x00,
  0x40, 0x60, 0xb5, 0x00, 0x58, 0x3f, 0x3c, 0xd8, 0x03, 0x00, 0x8b, 0x80,
  0x7d, 0x7e, 0xb5, 0x00, 0x7e, 0x9c, 0x3c, 0xd0, 0x00, 0x8e, 0x3c, 0xcb,
  0xff, 0xb4, 0x82, 0x14, 0x52, 0xf6, 0x6c, 0x3c, 0xd4, 0x78, 0xb5, 0x00,
  0x55, 0xfa, 0x3b, 0x46, 0x40, 0xb8, 0x95, 0xd4, 0xf9, 0x1a, 0xb5, 0x00,
  0x53, 0x77, 0xb5, 0x00, 0x52, 0xb6, 0x3c, 0xc5, 0x40, 0xb7, 0x6a, 0x5c,
  0x62, 0x0c, 0x61, 0x84, 0xfe, 0x9c, 0x7f, 0x20, 0xc3, 0x41, 0x3c, 0xc9,
  0xff, 0x72, 0x30, 0xa0, 0x02, 0x17, 0xfb, 0x00, 0x71, 0x40, 0xba, 0x9b,
  0xa0, 0xe2, 0x0b, 0x9b, 0xc0, 0xd6, 0x7b, 0x9b, 0x00, 0xd4, 0xfc, 0x8b,
  0x80, 0x55, 0x7d, 0x30, 0xb0, 0x21, 0x2c, 0x73, 0x05, 0xd3, 0xb7, 0xb5,
  0x00, 0x52, 0x7f, 0x3b, 0x80, 0x01, 0xda, 0x3a, 0x31, 0xff, 0xfe, 0x6a,
  0x1e, 0x54, 0xba, 0x7c, 0x01, 0x78, 0x4a, 0x6a, 0x7e, 0x52, 0xb7, 0x3b,
  0x80, 0x01, 0x00, 0xb5, 0x00, 0x54, 0x7a, 0x9b, 0xc0, 0xd2, 0xbf, 0x90,
  0x94, 0xd5, 0x3d, 0x3a, 0x92, 0x00, 0x04, 0x92, 0x11, 0xd5, 0xbe, 0x6a,
  0x1e, 0x54, 0xba, 0x3a, 0x9b, 0x00, 0x05, 0x7c, 0x27, 0x78, 0x06, 0xb5,
  0x00, 0x55, 0x7d, 0x3b, 0x44, 0x40, 0xbf, 0x80, 0x18, 0x54, 0x7a, 0x80,
  0xb8, 0x54, 0xfc, 0xb5, 0x00, 0x52, 0xb6, 0x82, 0x14, 0x7e, 0x9c, 0x3b,
  0x46, 0x40, 0xde, 0x6a, 0x5d, 0xd4, 0x38, 0x3c, 0xc5, 0x40, 0xdb, 0xb5,
  0x00, 0x43, 0x0b, 0x94, 0x18, 0xfe, 0x9c, 0xb5, 0x00, 0x43, 0x0b, 0x94,
  0x18, 0xc0, 0x41, 0x3b, 0x00, 0x40, 0xdf, 0xb5, 0x00, 0x58, 0x39, 0xb5,
  0x00, 0x58, 0x39, 0x3c, 0xd8, 0x03, 0x00, 0x8b, 0x80, 0x7e, 0x9c, 0x3c,
  0xd0, 0xff, 0x72, 0x71, 0x65, 0x7d, 0x2b, 0x6a, 0x7b, 0x42, 0x91, 0x6a,
  0xbb, 0xe2, 0x4b, 0x6a, 0x3d, 0x52, 0xf8, 0xb5, 0x00, 0x58, 0x7b, 0x3b,
  0x80, 0x16, 0x94, 0xb5, 0x00, 0x54, 0xf9, 0x7c, 0x44, 0xd4, 0xb8, 0x6a,
  0x1b, 0xc2, 0x91, 0x61, 0xc0, 0x7e, 0x9c, 0x6a, 0xbe, 0x54, 0xb6, 0x3b,
  0x80, 0x00, 0xa9, 0x9b, 0xc3, 0x62, 0x09, 0x6a, 0xdb, 0xd4, 0x3c, 0x3a,
  0x90, 0x00, 0x25, 0x61, 0xcc, 0x42, 0x80, 0x6a, 0xbe, 0x54, 0xba, 0x3b,
  0x80, 0x00, 0xa9, 0x9b, 0xc3, 0x62, 0x09, 0x9b, 0xa0, 0xd4, 0x37, 0x3a,
  0x88, 0x00, 0x96, 0x66, 0x04, 0x45, 0x0a, 0xfb, 0x00, 0x71, 0x40, 0xf8,
  0x3a, 0x99, 0xff, 0x6b, 0xb5, 0x00, 0x72, 0x81, 0x80, 0x18, 0x43, 0x80,
  0x6a, 0xfe, 0xd4, 0xba, 0x3b, 0x80, 0x02, 0x8f, 0x80, 0xd4, 0x62, 0x09,
  0x38, 0x12, 0x00, 0xcf, 0x38, 0x24, 0x00, 0xa5, 0x7f, 0x4e, 0x55, 0x3d,
  0x7b, 0x05, 0x43, 0x10, 0x3b, 0x80, 0x01, 0x33, 0x9b, 0xa2, 0x74, 0x56,
  0x7f, 0x4e, 0x55, 0x3d, 0xb5, 0x00, 0x43, 0x10, 0x3a, 0x82, 0x00, 0xc7,
  0x7a, 0x2b, 0x54, 0x7d, 0x30, 0xa0, 0x12, 0x00, 0x30, 0xb0, 0x0b, 0x66,
  0x30, 0x50, 0x00, 0x80, 0x3b, 0x80, 0x02, 0xbe, 0xb5, 0x00, 0x62, 0x09,
  0x7f, 0x4e, 0x55, 0x3c, 0xb5, 0x00, 0x43, 0x10, 0x90, 0xdb, 0x54, 0xbd,
  0x61, 0x44, 0x7e, 0x9c, 0xa2, 0x17, 0x55, 0x39, 0x3a, 0x92, 0x00, 0xc8,
  0x3a, 0x89, 0xff, 0xbe, 0x3b, 0x43, 0x41, 0x4a, 0x6a, 0xbf, 0x54, 0xfd,
  0x38, 0x12, 0x0b, 0x66, 0x30, 0x60, 0x00, 0x80, 0x30, 0x80, 0x12, 0x00,
  0x30, 0xa0, 0x01, 0x80, 0x3b, 0x80, 0x01, 0x1c, 0xb5, 0x00, 0x61, 0x46,
  0xb5, 0x00, 0x54, 0xb9, 0x30, 0x80, 0x01, 0x00, 0x30, 0x50, 0x01, 0x00,
  0x30, 0x70, 0x00, 0x80, 0x3b, 0x80, 0x1c, 0x3e, 0x38, 0x0c, 0x0b, 0x6b,
  0x30, 0x90, 0x01, 0x80, 0x38, 0x0a, 0x22, 0x01, 0x20, 0x80, 0x41, 0x29,
  0x30, 0xa0, 0x01, 0x00, 0xb5, 0x00, 0x42, 0x11, 0xb5, 0x00, 0x43, 0x08,
  0xd4, 0xc8, 0x42, 0x11, 0x60, 0x24, 0xfe, 0x9c, 0x30, 0x90, 0x01, 0x00,
  0x30, 0x50, 0x00, 0x80, 0x30, 0xa0, 0x22, 0x29, 0x3b, 0x80, 0x02, 0x60,
  0x30, 0x80, 0x01, 0x80, 0x30, 0x80, 0x01, 0x00, 0x30, 0x50, 0x00, 0x80,
  0x3b, 0x80, 0x00, 0xc1, 0x30, 0x90, 0x01, 0x00, 0x30, 0x90, 0x01, 0x00,
  0xb5, 0x00, 0x78, 0x09, 0x30, 0x50, 0x00, 0x3f, 0xfb, 0x00, 0x71, 0x41,
  0x36, 0x3b, 0x80, 0x00, 0x51, 0xb5, 0x00, 0x54, 0x7f, 0x38, 0x0a, 0x0b,
  0x60, 0xd0, 0x0c, 0x54, 0x3f, 0x30, 0x60, 0x00, 0x3f, 0x3b, 0x80, 0x00,
  0x7a, 0xb5, 0x00, 0x61, 0x40, 0x9b, 0xa8, 0x74, 0x55, 0xa5, 0xf2, 0xe2,
  0x09, 0x38, 0x09, 0x0b, 0x69, 0x38, 0x0a, 0x0b, 0x61, 0x38, 0x0c, 0x0a,
  0x7c, 0x30, 0xa0, 0x0b, 0x67, 0x3b, 0x80, 0x00, 0x89, 0x9b, 0xe0, 0xd3,
  0xd5, 0x38, 0x0c, 0x0b, 0x67, 0x9b, 0xa8, 0x54, 0xbd, 0xa6, 0x1a, 0xfe,
  0x9c, 0x3b, 0x00, 0x41, 0x4b, 0x38, 0x01, 0x0b, 0x69, 0x9b, 0xa8, 0x54,
  0xbd, 0x61, 0x84, 0x7e, 0x9c, 0x92, 0x1b, 0xfe, 0x9c, 0x3b, 0x63, 0x41,
  0x53, 0x38, 0x08, 0x0b, 0x6c, 0x9b, 0xdf, 0xd4, 0xbe, 0xa5, 0xb2, 0xc3,
  0x48, 0x38, 0x0b, 0x0b, 0x67, 0x38, 0x09, 0x0b, 0x69, 0x3b, 0x80, 0x41,
  0xd1, 0xb5, 0x00, 0x7e, 0x9c, 0x7f, 0x4e, 0x54, 0xbd, 0xb5, 0x00, 0x42,
  0x88, 0x3a, 0x91, 0xff, 0x7a, 0x31, 0x20, 0x00, 0xc8, 0x82, 0x14, 0x44,
  0x95, 0x3b, 0x44, 0x41, 0x61, 0x38, 0x0a, 0x0b, 0x6a, 0x3a, 0x81, 0x00,
  0x29, 0x38, 0x0c, 0x0b, 0x69, 0x38, 0x0e, 0x0b, 0x62, 0xa2, 0x1b, 0xfe,
  0x9c, 0x3b, 0x66, 0x41, 0x70, 0x38, 0x0c, 0x0a, 0x7a, 0xa2, 0x13, 0x7e,
  0x9c, 0x3b, 0x64, 0x41, 0x70, 0x38, 0x0c, 0x0a, 0x79, 0xa2, 0x13, 0x7e,
  0x9c, 0x3b, 0x67, 0x41, 0x70, 0x38, 0x0c, 0x0b, 0x63, 0xd0, 0x35, 0x54,
  0xb9, 0x3a, 0x89, 0x00, 0x50, 0xb5, 0x00, 0x1a, 0x61, 0x38, 0x00, 0x0b,
  0x68, 0x95, 0xd8, 0xc0, 0x40, 0xb3, 0xb7, 0x7e, 0x9c, 0x3b, 0x00, 0x41,
  0x77, 0x38, 0x0b, 0x0b, 0x6a, 0x38, 0x0c, 0x0b, 0x64, 0xd0, 0x34, 0x54,
  0xbe, 0x38, 0x0a, 0x0b, 0x65, 0x9b, 0x1f, 0xe1, 0x80, 0xfb, 0x00, 0x71,
  0x41, 0x74, 0x95, 0xd8, 0xfe, 0x40, 0xb2, 0xb7, 0x40, 0x48, 0x38, 0x0b,
  0x0b, 0x6a, 0x61, 0x08, 0x54, 0xbc, 0xb5, 0x00, 0x43, 0x08, 0xa2, 0x13,
  0x54, 0x3e, 0x3a, 0x92, 0xff, 0x94, 0x3b, 0x46, 0x41, 0x7f, 0x3a, 0x89,
  0xff, 0xeb, 0x9b, 0xbf, 0xd4, 0xfc, 0xb5, 0x00, 0x42, 0xc0, 0xb5, 0x00,
  0x42, 0x90, 0x3a, 0x8a, 0xff, 0xa5, 0x82, 0x14, 0x7e, 0x9c, 0x3b, 0x43,
  0x41, 0x92, 0x6a, 0x7b, 0xd5, 0x37, 0x3a, 0x8a, 0x00, 0x95, 0x31, 0x1f,
  0xff, 0x6a, 0x9b, 0xa0, 0xcc, 0x0d, 0x6a, 0x7e, 0xc3, 0x90, 0x6a, 0x1b,
  0x72, 0x81, 0xb5, 0x00, 0x74, 0x56, 0x30, 0xa0, 0x0e, 0xba, 0x3b, 0x80,
  0x02, 0x8f, 0x80, 0x18, 0x61, 0x85, 0x6a, 0x5d, 0x55, 0x3d, 0x3b, 0x80,
  0x1a, 0x0a, 0x3c, 0xc8, 0xff, 0xd6, 0x3b, 0x00, 0x41, 0x93, 0xb5, 0x00,
  0x54, 0xbc, 0xb5, 0x00, 0x54, 0xbc, 0x61, 0x44, 0x7e, 0x9c, 0x98, 0xb5,
  0x7e, 0x9c, 0x82, 0x14, 0x7e, 0x9c, 0x3b, 0x62, 0x41, 0xa4, 0x6a, 0x9c,
  0x54, 0xb9, 0x3a, 0x81, 0x00, 0x14, 0x3a, 0x8a, 0x00, 0x22, 0x61, 0x40,
  0x43, 0x08, 0x3a, 0x90, 0xff, 0xed, 0xd0, 0x4c, 0x43, 0x10, 0xb5, 0x00,
  0x54, 0xb6, 0x94, 0x03, 0xe2, 0x09, 0x30, 0xa0, 0x07, 0xa1, 0x3b, 0x80,
  0x00, 0x14, 0xb5, 0x00, 0x61, 0x40, 0x3b, 0x00, 0x41, 0xa5, 0xb5, 0x00,
  0x55, 0xb7, 0xb5, 0x00, 0x55, 0xb7, 0x3a, 0x83, 0x00, 0x97, 0x9b, 0xa0,
  0xc5, 0x04, 0x31, 0x0f, 0xff, 0x6a, 0x7f, 0x4e, 0x4c, 0x05, 0xb5, 0x00,
  0x72, 0x81, 0x80, 0x18, 0x43, 0x98, 0x6a, 0x3b, 0xd4, 0xb6, 0x3b, 0x80,
  0x02, 0x8f, 0x80, 0xd4, 0x62, 0x09, 0x6a, 0x5d, 0x55, 0x37, 0xb5, 0x00,
  0x54, 0x36, 0x3b, 0x80, 0x17, 0x99, 0xb5, 0x00, 0x7e, 0x9c, 0xfb, 0x00,
  0x71, 0x41, 0xb2, 0x8b, 0x80, 0x54, 0xb7, 0x3a, 0x89, 0x00, 0x5c, 0x3a,
  0x91, 0xff, 0xf2, 0x60, 0x00, 0x78, 0x11, 0x38, 0x0a, 0x0b, 0x6a, 0xb5,
  0x00, 0x4a, 0x10, 0xb3, 0x02, 0xc3, 0x08, 0x90, 0xdb, 0xca, 0x50, 0x3a,
  0x98, 0x00, 0x10, 0xb2, 0xd3, 0x42, 0x98, 0x92, 0x17, 0xc3, 0x48, 0xb5,
  0x00, 0x48, 0x40, 0x3b, 0x42, 0x41, 0xce, 0xb5, 0x00, 0x55, 0x39, 0x3a,
  0x9a, 0x00, 0x5d, 0xb5, 0x00, 0x43, 0x18, 0x82, 0x18, 0x7e, 0x9c, 0x3b,
  0x66, 0x41, 0xce, 0x3a, 0x8a, 0x00, 0x5e, 0xb5, 0x00, 0x43, 0x08, 0x90,
  0xd8, 0xfe, 0x9c, 0xa2, 0x1a, 0xc3, 0x48, 0x3b, 0x66, 0x41, 0xcc, 0x6c,
  0x1d, 0xfe, 0x4a, 0x3b, 0x00, 0x41, 0xcf, 0xb5, 0x00, 0x7e, 0x48, 0x3b,
  0x00, 0x41, 0xcf, 0xb5, 0x00, 0x58, 0x3b, 0xb5, 0x00, 0x58, 0x3b, 0x3c,
  0xd8, 0x03, 0x00, 0x7f, 0x4e, 0x7d, 0x55, 0x39, 0x84, 0x80, 0x02, 0x39,
  0x86, 0x80, 0x02, 0x30, 0x40, 0x01, 0x00, 0xa8, 0x1e, 0x7e, 0x9c, 0xa2,
  0x02, 0x7e, 0x9c, 0x3b, 0x43, 0x41, 0xdb, 0x30, 0x10, 0x01, 0xff, 0xa8,
  0x38, 0xfe, 0x9c, 0x30, 0x4f, 0xfe, 0x00, 0xa9, 0x26, 0x7e, 0x9c, 0x3c,
  0xd8, 0x03, 0x00, 0x9b, 0x99, 0x7e, 0x9c, 0xa0, 0x86, 0x7e, 0x9c, 0x3a,
  0x89, 0x00, 0xc7, 0x7e, 0x81, 0xc2, 0x88, 0x3a, 0x89, 0xff, 0xe9, 0x6a,
  0x3f, 0x54, 0xfd, 0xb5, 0x00, 0x58, 0x7f, 0x30, 0x60, 0x00, 0x80, 0x3b,
  0x80, 0x00, 0xb6, 0xb8, 0xa2, 0xe2, 0x48, 0xb5, 0x00, 0x54, 0xbe, 0x38,
  0x20, 0x0a, 0x6f, 0xb5, 0x00, 0x76, 0x88, 0x30, 0x62, 0x00, 0x00, 0xb5,
  0x00, 0x42, 0x90, 0xa0, 0xb7, 0x55, 0xbd, 0xb5, 0x00, 0x42, 0xd0, 0x38,
  0x0c, 0x22, 0x13, 0xb5, 0x00, 0x42, 0x98, 0xd0, 0x35, 0x7e, 0x9c, 0x43,
  0x00, 0x71, 0x41, 0xf0, 0x3a, 0x83, 0xff, 0x57, 0xb5, 0x00, 0x18, 0x61,
  0x3a, 0x90, 0x00, 0x9b, 0xd0, 0x4c, 0x62, 0x09, 0x30, 0x70, 0x00, 0x80,
  0xb5, 0x00, 0x55, 0x7d, 0x3b, 0x80, 0x00, 0xa9, 0x9b, 0xc6, 0x61, 0x40,
  0x7f, 0x4e, 0x54, 0xbd, 0x6a, 0x1f, 0x4c, 0x08, 0x3b, 0x80, 0x01, 0x0e,
  0x30, 0x50, 0x00, 0x80, 0xb5, 0x00, 0x58, 0x3f, 0x3c, 0xd8, 0x03, 0x00,
  0x8b, 0x80, 0x7d, 0x7d, 0xb5, 0x00, 0x7e, 0x9c, 0x03, 0x00, 0x70, 0x00,
  0x03, 0x21, 0x00, 0x71, 0x0a, 0x6f, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06,
  0x2d, 0x00, 0x71, 0x0b, 0x60, 0x00, 0xb8, 0x45, 0x7f, 0xea, 0x29, 0x00,
  0x00, 0x07, 0x40, 0x0f, 0x26, 0x3f, 0xff, 0x9f, 0x02, 0xcc, 0xcd, 0x00,
  0x12, 0x00, 0x40, 0x00, 0x00, 0x01, 0x47, 0xae, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x0f,
  0x00, 0x71, 0x0a, 0x79, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x05, 0x00, 0x00,
  0x00, 0x7e, 0x4d, 0xfe, 0x03, 0x00, 0x70, 0x00, 0x05, 0x03, 0x00, 0x70,
  0x00, 0x07, 0x7b, 0x00, 0x71, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0b,
  0x23, 0x00, 0x40, 0x00, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x0b,
  0xab, 0x00, 0x40, 0x24, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x0d,
  0xf5, 0x00, 0x40, 0x3a, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x0a,
  0x6b, 0x00, 0x40, 0x97, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x05,
  0xc6, 0x00, 0x40, 0xab, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x0d,
  0x24, 0x00, 0x40, 0xe2, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x12,
  0x3a, 0x00, 0x7e, 0x9c, 0x00, 0xb5, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05,
  0x7b, 0x00, 0x41, 0xd1, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x01, 0x00, 0x1b,
  0xa7, 0x00, 0x41, 0xde, 0x00, 0x3b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x70, 0x00, 0x00,
  0x23, 0x00, 0x70, 0x00, 0x02, 0x00, 0x01, 0x00, 0x80, 0x03, 0xff, 0xff,
  0xf9, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xf6, 0x00, 0x00, 0x1d, 0x00, 0x00,
  0x1b, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1c, 0x00, 0x00,
  0x1c, 0x03, 0x00, 0x70, 0x01, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xa7, 0x01, 0x00, 0x00, 0xff, 0xfd, 0xda, 0xff,
  0xfe, 0x4d, 0xff, 0xfe, 0x5e, 0xff, 0xfe, 0x22, 0xff, 0xfe, 0xdd, 0xff,
  0xfd, 0x64, 0xff, 0xff, 0x03, 0xff, 0xfe, 0x17, 0xff, 0xfc, 0x9c, 0xff,
  0xff, 0x05, 0xff, 0xfd, 0x14, 0xff, 0xfe, 0x0e, 0xff, 0xfb, 0xa6, 0xff,
  0xfe, 0x80, 0xff, 0xfe, 0x05, 0x00, 0x00, 0x4b, 0xff, 0xfe, 0xa7, 0xff,
  0xfe, 0x2d, 0xff, 0xfe, 0x15, 0xff, 0xfd, 0xa1, 0xff, 0xfd, 0xff, 0xff,
  0xfd, 0x23, 0xff, 0xfd, 0x67, 0xff, 0xfc, 0x8c, 0xff, 0xff, 0x64, 0xff,
  0xfd, 0x43, 0xff, 0xfd, 0xfd, 0xff, 0xfd, 0xbd, 0xff, 0xfd, 0x33, 0xff,
  0xfc, 0x49, 0xff, 0xff, 0x2f, 0xff, 0xfb, 0x31, 0x00, 0x00, 0x1b, 0xff,
  0xfc, 0xed, 0xff, 0xff, 0xa9, 0xff, 0xfb, 0x1c, 0x00, 0x00, 0x7e, 0xff,
  0xf9, 0x9c, 0xff, 0xfe, 0xf3, 0xff, 0xfc, 0x16, 0xff, 0xfd, 0x5d, 0xff,
  0xfd, 0xd3, 0xff, 0xfd, 0xd3, 0xff, 0xfb, 0x75, 0xff, 0xff, 0x77, 0xff,
  0xfb, 0xcd, 0xff, 0xfe, 0x79, 0xff, 0xfb, 0x3a, 0xff, 0xfc, 0x28, 0xff,
  0xfd, 0x43, 0xff, 0xfb, 0xca, 0xff, 0xfd, 0xa4, 0xff, 0xfb, 0xdb, 0xff,
  0xfd, 0xad, 0xff, 0xfc, 0x48, 0xff, 0xfd, 0x39, 0xff, 0xfa, 0x51, 0xff,
  0xfd, 0x00, 0xff, 0xfc, 0x05, 0xff, 0xfc, 0x5a, 0xff, 0xfb, 0xda, 0xff,
  0xfb, 0xf4, 0xff, 0xfb, 0x82, 0xff, 0xfe, 0xb2, 0xff, 0xfb, 0x20, 0xff,
  0xfd, 0x31, 0xff, 0xfc, 0x41, 0xff, 0xfb, 0x5c, 0xff, 0xfb, 0x5a, 0xff,
  0xfb, 0x65, 0xff, 0xfb, 0x9c, 0xff, 0xfc, 0xc8, 0xff, 0xfc, 0xf4, 0xff,
  0xfd, 0xfd, 0xff, 0xfa, 0xdb, 0xff, 0xfd, 0x98, 0xff, 0xf8, 0xdd, 0xff,
  0xfa, 0x87, 0xff, 0xfa, 0xfa, 0xff, 0xfc, 0x3f, 0xff, 0xfc, 0xd5, 0xff,
  0xfc, 0xea, 0xff, 0xff, 0x22, 0xff, 0xfc, 0xa1, 0xff, 0xfb, 0x57, 0xff,
  0xf6, 0xe0, 0xff, 0xf7, 0x18, 0xff, 0xf5, 0xf4, 0xff, 0xfb, 0x10, 0xff,
  0xfa, 0xf3, 0x00, 0x06, 0xda, 0x00, 0x02, 0x98, 0x00, 0x08, 0x24, 0xff,
  0xf9, 0x8f, 0xff, 0xf9, 0x06, 0xff, 0xe1, 0x97, 0xff, 0xef, 0x74, 0xff,
  0xe0, 0x02, 0x00, 0x05, 0x51, 0x00, 0x01, 0x07, 0x00, 0x2f, 0x18, 0x00,
  0x13, 0xce, 0x00, 0x2e, 0x58, 0xff, 0xde, 0x37, 0xff, 0xea, 0x91, 0xff,
  0x8f, 0xff, 0xff, 0xcc, 0x0d, 0xff, 0x9e, 0xf0, 0x00, 0x40, 0x7c, 0x00,
  0x24, 0x43, 0x00, 0xda, 0x5a, 0x00, 0x4b, 0xa9, 0x00, 0xad, 0x10, 0xff,
  0x3a, 0x6e, 0x00, 0x5c, 0x45, 0x06, 0x81, 0x0d, 0xff, 0x9e, 0x94, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53,
  0x33, 0x33, 0x79, 0x99, 0x9a, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x20,
  0x00, 0x00, 0x18, 0xf5, 0xc3, 0x00, 0x03, 0x2a, 0x00, 0x03, 0x2a, 0x04,
  0x00, 0x00, 0x00, 0x67, 0xae, 0x1c, 0xc0, 0x00, 0x00, 0x6f, 0x69, 0x00,
  0xa5, 0x00, 0x00, 0x00, 0x09, 0xf3, 0x33, 0x01, 0x3e, 0x66, 0x00, 0x54,
  0xcd, 0x00, 0x00, 0x14, 0x00, 0x00, 0x02, 0x1a, 0xe6, 0x40, 0x1b, 0x40,
  0xd4, 0x1c, 0x59, 0xda, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x4b, 0x00, 0x01,
  0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x01, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x80,
  0x00, 0x20, 0x00, 0x00, 0x00, 0x03, 0x47, 0x01, 0x47, 0xae, 0x00, 0x19,
  0x9a, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xcd, 0x02, 0x80, 0x00, 0x00, 0x00,
  0x01, 0x05, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x07, 0xc2,
  0x8f, 0x00, 0x10, 0x00, 0x08, 0x00, 0x00, 0x00, 0x19, 0x9a, 0x00, 0x00,
  0x80, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x01, 0x47, 0xae, 0x00, 0x00,
  0x40, 0x00, 0x00, 0x00, 0x19, 0x99, 0x9a, 0x00, 0x80, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x30, 0x00, 0x00, 0x02, 0x00, 0x00, 0x18, 0xec, 0x00,
  0x00, 0x00, 0x03, 0xd7, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
  0x44, 0xac, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x07, 0x00, 0x01, 0x2c, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x1f, 0x40, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x47, 0xae,
  0x00, 0x2b, 0xb1, 0x00, 0x00, 0x9d, 0x00, 0x0d, 0x1b, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00,
  0x05, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x0c, 0xcd, 0x00, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x48,
  0x00, 0x01, 0x48, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0c, 0xcd,
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};
/*
 * Initialization of parameter
 */
nxpTfa98xx_Error_t nxpTfa98xxInit (void)
{
   Tfa98xx_Error_t err;

   memcpy((void*)&tfaParams, devkit_parms, sizeof(nxpTfa98xxParameters_t));
#ifdef WIN32
   err = Tfa98xx_I2C_Init();
#endif
   return (nxpTfa98xx_Error_t) err;
}
#ifndef WIN32
#include <libgen.h>

/*
 * dump the params into files
 */
static int outFile(int length, void *buffer, char *basename, char *ext)
{char *base, *ptr, outfile[80];
FILE *out;


	strncpy(outfile, basename, sizeof(outfile));
	strcat(outfile, ext);
	out = fopen( outfile, "wb");
	if(out==0) {
		printf("%s: can't open:%s\n", __FUNCTION__, outfile);
		return 0;
	}
	if ( length ) {
			fwrite(buffer, length, 1, out);
			fclose(out);
			printf("created %s (%d bytes)\n", outfile,
					length);
	}	\
	return length;
}
void tfa98xxDumpParams(char *parmsFilename)
{
	char *filename[]={".patch", ".speaker", ".config", ".preset"};
	char *base, *ptr, outfile[80];
	FILE *out;
	int i, length;
	void *buf;

	//strncpy (base, parmsFilename, sizeof(base));
	base = basename(parmsFilename);

	ptr = strrchr(base, (int)'.');
	if (ptr)
		*ptr='\0';
	else
	{
		printf("%s: bad parm filename:%s\n", __FUNCTION__, parmsFilename);
		return;
	}

	i=0;
	strncpy(outfile, base, sizeof(outfile));
	outFile(tfaParams.patchLength, (void*) tfaParams.patchBuffer,
			base , filename[i++]);
	outFile(tfaParams.speakerLength, (void*) tfaParams.speakerBuffer,
			base , filename[i++]);
	outFile(tfaParams.configLength, (void*) tfaParams.configBuffer,
			base , filename[i++]);
	outFile(TFA98XX_PRESET_LENGTH, (void*) tfaParams.profile[nxpTfaCurrentProfile].vstep[0].CF,
			base , filename[i++]);

//	strncpy(outfile, base, sizeof(outfile));
//	strcat(outfile, filename[i]);
//	out = fopen( outfile, "wb");
//	if(out==0) {
//		printf("%s: can't open:%s\n", __FUNCTION__, outfile);
//		return;
//	}
//	if ( tfaParams.patchLength ) {
//			fwrite((void*) tfaParams.patchBuffer, tfaParams.patchLength, 1, out);
//			fclose(out);
//			printf("created %s (%d bytes)\n", outfile,
//					tfaParams.patchLength);
//	}
//	i++;
//	strncpy(outfile, base, sizeof(outfile));
//	strcat(outfile, filename[i]);
//	out = fopen( outfile, "wb");
//	if(out==0) {
//		printf("%s: can't open:%s\n", __FUNCTION__, outfile);
//		return;
//	}
//	if ( tfaParams.speakerLength ) {
//			fwrite((void*) tfaParams.speakerBuffer, tfaParams.speakerLength, 1, out);
//			fclose(out);
//			printf("created %s (%d bytes)\n", outfile,
//					tfaParams.speakerLength);
//	}

}
#endif
